<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  
<title>Migrations</title>

<link rel="stylesheet" type="text/css" href="files/stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/syntax.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/print.css" media="print" />

<script type="text/javascript" src="files/javascripts/guides.js"></script>
<script type="text/javascript" src="files/javascripts/code_highlighter.js"></script>
<script type="text/javascript" src="files/javascripts/highlighters.js"></script>

</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>Mais em <a href="http://www.rubyonrails.pro.br/">rubyonrails.pro.br:</a> </strong>
      <a href="http://www.rubyonrails.pro.br/">Geral</a> |
      <a href="http://rubyonrails.pro.br/down">Download</a> |
      <a href="http://rubyonrails.pro.br/deploy">Deploy</a> |
      <a href="http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/overview">C&oacute;digo</a> |
      <a href="http://www.rubyonrails.pro.br/apresentacoes">Apresentações</a> |
      <a href="http://www.rubyonrails.pro.br/documentacao">Documentação</a> |
      <a href="http://www.rubyonrails.pro.br/ecossistema">Ecossistema</a> |
      <a href="http://www.rubyonrails.pro.br/comunidade">Comunidade</a> |
      <a href="http://podcast.rubyonrails.pro.br">Podcasts</a> |
      <a href="http://www.rubyonrails.pro.br/planeta/">Blogs</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Retorne para a página princípal">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Pule a navegação</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Início</a></li>
        <li class="index"><a href="#" onclick="guideMenu();" id="guidesMenu">Índice dos Guias</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Começando com Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="activerecord_validations_callbacks.html">Validações e Callbacks do Active Record</a></dd>
              <dd><a href="association_basics.html">Associações do Active Record</a></dd>
              <dd><a href="active_record_querying.html">Interface de Queries do Active Record</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts e Renderização no Rails</a></dd>
              <dd><a href="form_helpers.html">Form Helpers do Action View</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Visão Geral do Action Controller</a></dd>
              <dd><a href="routing.html">Roteamento Rails de Fora para Dentro</a></dd>
            </dl>
            <dl class="R">
              <dt>Aprofundando</dt>
              <dd><a href="i18n.html">API de Internacionalização do Rails</a></dd>
              <dd><a href="action_mailer_basics.html">Conceitos Básicos do Action Mailer</a></dd>
              <dd><a href="testing.html">Testando Aplicações Rails</a></dd>
              <dd><a href="security.html">Segurança em Aplicações Rails</a></dd>
              <dd><a href="debugging_rails_applications.html">Depurando Aplicações Rails</a></dd>
              <dd><a href="performance_testing.html">Testando Performance em Aplicações Rails</a></dd>
              <dd><a href="plugins.html">O Básico da Criação de Plugins</a></dd>
              <dd><a href="configuring.html">Configurando Aplicações Rails</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contribute.html">Contribua</a></li>
        <li><a href="credits.html">Créditos</a></li>
      </ul>     
    </div>
  </div>
  <hr class="hide" />
  
  <div id="feature">
    <div class="wrapper">
      <h2>Migrations</h2>
<p>Migrations é a forma conveniente de você alterar seu banco de dados de uma maneira organizada e estruturada. Você poderia editar fragmentos de <span class="caps">SQL</span> na mão mas teria a responsabilidade de comunicar aos outros desenvolvedores que eles precisam executá-los. Você também necessitaria acompanhar as mudanças na máquina de produção na próxima vez que você fosse fazer um deploy. O Active Record marca as migrations que já foram executadas, então tudo que você precisa fazer é atualizar seu código e rodar <tt>rake db:migrate</tt>. O Active Record saberá quais migrations devem ser rodadas. Ele também irá atualizar o seu arquivo db/schema.rb para refletir a estrutura da sua base de dados.</p>
<p>As migrations também permitem que você descreva estas transformações usando Ruby. A grande sacada disto tudo (como a maioria das funcionalidades do Active Record) é a independência do banco de dados: você não precisa se preocupar com mais nenhuma sintaxe para <span class="caps">CREATE</span> <span class="caps">TABLE</span>, ou sobre variações de <span class="caps">SELECT</span> * (você pode abstrair os requisitos específicos de banco de dados <span class="caps">SQL</span>). Por exemplo, você poderia usar SQLite 3 no desenvolvimento, mas MySQL em produção.</p>
<p>Você aprenderá tudo sobre migrations incluindo:</p>
<ul>
	<li>Os geradores que você pode usar para criá-las</li>
	<li>Os métodos que o Active Record provê para manipular seu banco de dados</li>
	<li>As tarefas Rake que as manipulam</li>
	<li>Como elas se relacionam com o <tt>schema.rb</tt></li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#anatomia-de-uma-migration">Anatomia de uma Migration</a><ul><li><a href="#migrations-so-classes">Migrations são classes</a></li><li><a href="#o-que-h-em-um-nome">O que há em um Nome</a></li><li><a href="#alterando-migrations">Alterando Migrations</a></li></ul></li><li><a href="#criando-uma-migration">Criando uma Migration</a><ul><li><a href="#criando-um-model">Criando um Model</a></li><li><a href="#criando-uma-migration-standalone">Criando uma Migration Standalone</a></li></ul></li><li><a href="#escrevendo-uma-migration">Escrevendo uma Migration</a><ul><li><a href="#criando-uma-tabela">Criando uma Tabela</a></li><li><a href="#alterando-tabelas">Alterando Tabelas</a></li><li><a href="#helpers-especiais">Helpers Especiais</a></li><li><a href="#escrevendo-o-seu-mtodo-down--parei-aqui---adolfo-">Escrevendo o seu Método <tt>down</tt> <b>* <span class="caps">PAREI</span> <span class="caps">AQUI</span> &#8211; Adolfo *</b></a></li></ul></li><li><a href="#executando-migraes">Executando migrações</a><ul><li><a href="#reverso">Reversão</a></li><li><a href="#especificando-uma-migration">Especificando uma migration</a></li><li><a href="#sendo-comunicativo">Sendo comunicativo</a></li></ul></li><li><a href="#usando-models-nas-suas-migraes">Usando models nas suas migrações</a><ul><li><a href="#lidando-com-mudanas-nos-modelos">Lidando com mudanças nos modelos</a></li></ul></li><li><a href="#armazenando-esquemas-e-voc">Armazenando esquemas e você</a><ul><li><a href="#quais-so-os-arquivos-do-esquema">Quais são os arquivos do esquema?</a></li><li><a href="#formas-de-armazenar-o-esquema">Formas de armazenar o esquema</a></li><li><a href="#armazenamento-de-esquema-e-controle-de-cdigo">Armazenamento de esquema e controle de código</a></li></ul></li><li><a href="#active-record-e-integridade-referencial">Active Record e Integridade Referencial</a><ul></ul></li><li><a href="#changelog">Changelog</a><ul></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="anatomia-de-uma-migration">1 Anatomia de uma Migration</h3>
<p>Antes de eu mergulhar nos detalhes de uma migration, aqui estão alguns exemplos curtos de coisas que você pode fazer:</p>
<div class="code_container"><code class="ruby">
class CreateProducts &lt; ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def self.down
    drop_table :products
  end
end
</code></div>
<p>Esta migration adiciona uma tabela chamada <tt>products</tt> com uma coluna string chamada <tt>name</tt> e uma coluna text chamada <tt>description</tt>. Uma chave primária chamada <tt>id</tt> também será adicionada, no entanto, por padrão, não precisamos pedir isso. As colunas timestamps <tt>created_at</tt> e <tt>updated_at</tt> que o Active Record preenche automaticamente também serão adicionadas. Reverter esta migration simplesmente remove a tabela.</p>
<p>Migrações não estão limitadas a alterar o schema. Você também as pode usar para corrigir dados incorretos no banco ou popular novos campos:</p>
<div class="code_container"><code class="ruby">
class AddReceiveNewsletterToUsers &lt; ActiveRecord::Migration
  def self.up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default =&gt; false
    end
    User.update_all [&quot;receive_newsletter = ?&quot;, true]
  end

  def self.down
    remove_column :users, :receive_newsletter
  end
end
</code></div>
<p>Esta migration adiciona a coluna <tt>receive_newsletter</tt> na tabela <tt>users</tt>. Nós queremos que o padrão seja <tt>falso</tt> para novos usuários, mas para os usuários existentes, consideramos que eles já fizeram a sua opção, então usamos o model User para setar a flag como <tt>true</tt> para os usuários existentes.
 
<div class='note'><p>Algumas <a href="#usando-models-nas-suas-migraes">ressalvas</a> se aplicam ao utilizar models nas suas migrations.</p></div></p>
<h4 id="migrations-so-classes">1.1 Migrations são classes
A migration é uma subclasse de ActiveRecord::Migration que implementa dois métodos: up (para realizar as transformações exigidas) e down (reverte o que foi feito).</h4>
<p>O Active Record fornece métodos que executam tarefas comuns para definição dos dados de um modo independente do banco de dados (você lerá sobre elas com detalhes mais tarde):</p>
<ul>
	<li><tt>create_table</tt></li>
	<li><tt>change_table</tt></li>
	<li><tt>drop_table</tt></li>
	<li><tt>add_column</tt></li>
	<li><tt>remove_column</tt></li>
	<li><tt>change_column</tt></li>
	<li><tt>rename_column</tt></li>
	<li><tt>add_index</tt></li>
	<li><tt>remove_index</tt></li>
</ul>
<p>Se você precisa executar tarefas específicas para seu banco de dados (por exemplo, criar uma <a href="#active-record-e-integridade-referencial">foreign key</a>) então a função <tt>execute</tt> permite que você execute <span class="caps">SQL</span> arbitrárias. A migration é apenas uma classe comum em Ruby, então você não está limitado a apenas estas funções. Por exemplo, após adicionar uma coluna, você pode escrever código para setar o valor dessa coluna para dados existentes (se necessário usando seus models).</p>
<p>Em banco de dados que suportam transações com parâmetros para mudar o schema (como o PostreSQL), as migrations entram em uma transação. Se o banco de dados não suporta isso (por exemplo MySQL e SQLite) então quando a migration falhar, as partes que tiveram sucesso não poderão ser revertidas. Você terá que desfazer estas mudanças manualmente.</p>
<h4 id="o-que-h-em-um-nome">1.2 O que há em um Nome</h4>
<p>Migrations são armazenadas em arquivos dentro de <tt>db/migrate</tt>, um para cada classe de migration. O nome dos arquivos é na forma de <tt>YYYYMMDDHHMMSS_create_products.rb</tt>, ou seja, uma hora <span class="caps">UTC</span> identificando a migration seguida de um underscore seguido pelo nome da migration. O nome da classe de migration deve bater com a última parte do arquivo. Por exemplo, <tt>20080906120000_create_products.rb</tt> deverá definir CreateProducts e <tt>20080906120001_add_details_to_products.rb</tt> deverá definir AddDetailsToProducts. Se você acha que necessita mudar o nome do arquivo, então você <em>deve</em> atualizar o nome da classe dentro do arquivo ou então o Rails irá se queixar de uma classe inexistente.</p>
<p>Internamente, o Rails usa apenas o número da migration (data) para identificá-la. Antes do Rails 2.1, os números das migrations eram iniciados com 1 e incrementados cada vez que era gerada uma nova migration. Com vários desenvolvedores, era fácil haver conflitos, o que te forçava a reverter as migrations e renumerá-las. Com o Rails 2.1, isto é evitado usando a hora de geração da migration para identificá-las. Você pode mudar para o esquema da velha numeração setando <tt>config.active_record.timestamped_migrations</tt> para <tt>false</tt> no <tt>environment.rb</tt>.</p>
<p>A combinação de timestamps e o registro de quais migrations já foram rodadas permite que o Rails trate situações comuns que ocorrem com múltiplos desenvolvedores.</p>
<p>Por exemplo, Alice adiciona as migrations <tt>20080906120000</tt> e <tt>20080906123000</tt> e Bob adiciona a <tt>20080906124500</tt> e a executa. Alice finaliza suas mudanças, comita suas migrations e Bob puxa as últimas atualizações. O Rails sabe que ele não rodou as duas migrations da Alice, então <tt>rake db:migrate</tt> deverá executá-las (mesmo que a migration com um timestamp maior do Bob já tenha sido rodada), e, similarmente, reverter as migrations não deverá executar os seus métodos <tt>down</tt>.</p>
<p>Claro que isso não substitui a comunicação dentro da equipe. Por exemplo, se a migration da Alice remove uma tabela que a migration do Bob assume que existe, então problemas deverão certamente acontecer.</p>
<h4 id="alterando-migrations">1.3 Alterando Migrations</h4>
<p>Ocasionalmente, você comete um erro enquanto escreve uma migration. Se você já tiver executado a migration, então você não pode simplesmente editar e executar novamente a migration: o Rails sabe que a migration já foi executada, então ele não fará nada quando você rodar <tt>rake db:migrate</tt>. Você deve reverter a migration (com <tt>rake db:rollback</tt>, por exemplo), editar sua migration e então executar <tt>rake db:migrate</tt> para rodar a versão corrigida.</p>
<p>Geralmente, editar migrations existentes não é uma boa idéia: você estará criando trabalho extra para você mesmo e para seus parceiros de trabalho e mais dor de cabeça se a versão existente da migration já tiver sido rodada em máquinas de produção. Em vez disso, você deve escrever uma nova migration para realizar as alterações que você queira. Editar uma migration recém-gerada e que ainda não foi comitada no controlador de versão (ou, de modo geral, que ainda não foi propagada para além da sua máquina de desenvolvimento) é relativamente inofensivo. Apenas use o bom senso.</p>
<h3 id="criando-uma-migration">2 Criando uma Migration</h3>
<h4 id="criando-um-model">2.1 Criando um Model</h4>
<p>Os models e os geradores de scaffold criarão as migrations apropriadas para a geração de um novo model. Esta migration já terá instruções para a criação da tabela relacionada. Se você disser pro Rails as colunas que você precisa, então as declarações já estarão criadas. Por exemplo, executar</p>
<div class="code_container"><code class="html">
ruby script/generate model Product name:string description:text
</code></div>
<p>gerará uma migration como esta</p>
<div class="code_container"><code class="ruby">
class CreateProducts &lt; ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def self.down
    drop_table :products
  end
end
</code></div>
<p>Você pode adicionar quantos pares nomes/tipo de colunas queira. Por padrão <tt>t.timestamps</tt> (que cria as colunas <tt>updated_at</tt> e <tt>created_at</tt> que são populadas automaticamente pelo Active Record) será adicionada por você.</p>
<h4 id="criando-uma-migration-standalone">2.2 Criando uma Migration Standalone</h4>
<p>Se você está criando migrations para outros propósitos (por exemplo, adicionar uma coluna em uma tabela já existente) então você pode usar o gerador de migrations:</p>
<div class="code_container"><code class="html">
ruby script/generate migration AddPartNumberToProducts
</code></div>
<p>Isto irá criar uma migration vazia mas já nomeada apropriadamente:</p>
<div class="code_container"><code class="ruby">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  def self.up
  end

  def self.down
  end
end
</code></div>
<p>Se o nome da migration é na forma &#8220;AddXXXtoYYY&#8221; ou &#8220;RemoveXXXtoYYY&#8221; e for seguida de uma lista de nomes de colunas e seus tipos então uma migration contendo as declarações <tt>add_column</tt> e <tt>remove_column</tt> será criada.</p>
<div class="code_container"><code class="html">
ruby script/generate migration AddPartNumberToProducts part_number:string
</code></div>
<p>vai gerar</p>
<div class="code_container"><code class="ruby">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  def self.up
    add_column :products, :part_number, :string
  end

  def self.down
    remove_column :products, :part_number
  end
end
</code></div>
<p>Analogamente,</p>
<div class="code_container"><code class="html">
ruby script/generate migration RemovePartNumberFromProducts part_number:string
</code></div>
<p>gera</p>
<div class="code_container"><code class="ruby">
class RemovePartNumberFromProducts &lt; ActiveRecord::Migration
  def self.up
    remove_column :products, :part_number
  end

  def self.down
    add_column :products, :part_number, :string
  end
end
</code></div>
<p>Você não está limitado a uma coluna gerada magicamente, por exemplo</p>
<div class="code_container"><code class="html">
ruby script/generate migration AddDetailsToProducts part_number:string price:decimal
</code></div>
<p>irá gerar</p>
<div class="code_container"><code class="ruby">
class AddDetailsToProducts &lt; ActiveRecord::Migration
  def self.up
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end

  def self.down
    remove_column :products, :price
    remove_column :products, :part_number
  end
end
</code></div>
<p>Como sempre, o que foi gerado para você é apenas um ponto de partida. Você pode adicionar ou remover o conteúdo gerado caso veja alguma necessidade.</p>
<h3 id="escrevendo-uma-migration">3 Escrevendo uma Migration</h3>
<p>Uma vez que você criou a sua migration usando um dos geradores, é hora de trabalhar!</p>
<h4 id="criando-uma-tabela">3.1 Criando uma Tabela</h4>
<p>O método <tt>create_table</tt> da migration será um dos mais usados. Um uso comum seria</p>
<div class="code_container"><code class="ruby">
create_table :products do |t|
  t.string :name
end
</code></div>
<p>que cria uma tabela <tt>products</tt> com uma coluna chamada <tt>name</tt> (e como discutido anteriormente, implicitamente criará uma coluna <tt>id</tt>).</p>
<p>O objeto passado para o bloco permite criar colunas na tabela. Existem duas formas de se fazer isso. A primeira (tradicional) é algo assim</p>
<div class="code_container"><code class="ruby">
create_table :products do |t|
  t.column :name, :string, :null =&gt; false
end
</code></div>
<p>a segunda forma, que é chamada de &#8220;sexy&#8221; migration, remove o método redundante <tt>column</tt>. Em vez de <tt>string</tt>, <tt>integer</tt>, etc os métodos criam uma coluna daquele tipo. Parâmetros subseqüentes são idênticos.</p>
<div class="code_container"><code class="ruby">
create_table :products do |t|
  t.string :name, :null =&gt; false
end
</code></div>
<p>Por padrão, <tt>create_table</tt> criará uma chave primária chamada <tt>id</tt>. Você pode alterar o nome da chave primária com a opção <tt>:primary_key</tt> (não esqueça de atualizar o modelo correspondente) ou se você não quiser uma chave primária (por exemplo para uma tabela join <span class="caps">HABTM</span>) você pode passar <tt>:id ⇒ false</tt>. Se você precisa passar alguma informação específica do banco de dados, você pode passar um fragmento <span class="caps">SQL</span> na opção <tt>:options</tt>. Por exemplo:</p>
<div class="code_container"><code class="ruby">
create_table :products, :options =&gt; &quot;ENGINE=BLACKHOLE&quot; do |t|
  t.string :name, :null =&gt; false
end
</code></div>
<p>vai concatenar <tt>ENGINE=BLACKHOLE</tt> na sql usada para criar a tabela (quando se usa MySQL por padrão é usado &#8220;<span class="caps">ENGINE</span>=InnoDB&#8221;).</p>
<p>Os tipos que o Active Record suporta são <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>, <tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>.</p>
<p>Eles vão ser mapeados apropriadamente para cada banco de dados, por exemplo com MySQL <tt>:string</tt> é mapeada para <tt>VARCHAR(255)</tt>. Você pode criar colunas e tipos não suportados pelo Active Record usando a sintaxe não-sexy, por exemplo:</p>
<div class="code_container"><code class="ruby">
create_table :products do |t|
  t.column :name, 'polygon', :null =&gt; false
end
</code></div>
<p>Isto, no entanto, pode dificultar a portabilidade para outros bancos de dados.</p>
<h4 id="alterando-tabelas">3.2 Alterando Tabelas</h4>
<p>Um primo próximo de <tt>create_table</tt> é <tt>change_table</tt>, usado para alterar tabelas existentes. É usado de um modo parecido com o  <tt>create_table</tt> mas o objeto passado para o bloco conhece mais truques. Por exemplo</p>
<div class="code_container"><code class="ruby">
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
</code></div>
<p>remove as colunas <tt>description</tt> e <tt>name</tt>, adiciona a coluna <tt>part_number</tt> e adiciona um index nesta mesma coluna. E por ultimo altera o nome da coluna <tt>upccode</tt>. É o mesmo que fazer</p>
<div class="code_container"><code class="ruby">
remove_column :products, :description
remove_column :products, :name
add_column :products, :part_number, :string
add_index :products, :part_number
rename_column :products, :upccode, :upc_code
</code></div>
<p>Você não precisa ficar repetindo o nome da tabela e de seus grupos em todas as expressões relacionadas à alteração de uma tabela em particular. Os nomes individuais de alteração são também mais curtos, por exemplo, <tt>remove_column</tt> se torna somente <tt>remove</tt> e <tt>add_index</tt> se torna <tt>index</tt>.</p>
<h4 id="helpers-especiais">3.3 Helpers Especiais</h4>
<p>O Active Record fornece alguns atalhos para as funcionalidades mais comuns. Por exemplo, é muito comum adicionar as colunas <tt>created_at</tt> e <tt>updated_at</tt> e há um método que faz exatamente isso:</p>
<p>dirty_workaround_for_nontextile_19
Criará uma tabela products com essas duas colunas</p>
<p>dirty_workaround_for_nontextile_20
vai criar uma nova tabela products com aquelas duas colunas (mais a coluna <tt>id</tt>) enquanto</p>
<p>dirty_workaround_for_nontextile_21
adiciona as colunas em uma tabela existente.</p>
<p>O outro helper é chamado de <tt>references</tt> (também disponível como <tt>belongs_to</tt>). Na sua forma mais simples, adiciona alguma legibilidade</p>
<div class="code_container"><code class="ruby">
create_table :products do |t|
  t.references :category
end
</code></div>
<p>criará uma coluna <tt>category_id</tt> do tipo apropriado. Note que você passa o nome do model, não o nome da coluna. O Active Recorde adiciona o <tt>_id</tt> pra você. Se você tem associações polimórficas <tt>belongs_to</tt>, então <tt>references</tt> irá adicionar as duas colunas necessárias:</p>
<p>dirty_workaround_for_nontextile_23
irá adicionar a coluna <tt>attachment_id</tt> e a coluna <tt>attachment_type</tt> do tipo string com o valor padrão &#8216;Photo&#8217;.</p>
<div class='note'><p>O helper <tt>references</tt> realmente não cria restrições de chave estrangeira. Você precisará usar <tt>execute</tt> para isso ou um plugin que adiciona <a href="#active-record-and-referential-integrity">foreign key support</a>.</p></div>
<p>Se os helpers fornecidos pelo Active Record não forem suficientes, você pode utilizar a função <tt>execute</tt> para rodar <span class="caps">SQL</span> arbitrárias.</p>
<p>Para mais detalhes e exemplos de métodos individuais dê uma olhada na documentação da <span class="caps">API</span>, em particular a documentação para <a href="http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html">ActiveRecord::ConnectionAdapters::SchemaStatements</a> (na qual fornece os métodos disponíveis nos métodos <tt>up</tt> e <tt>down</tt>), <a href="http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html">ActiveRecord::ConnectionAdapters::TableDefinition</a> (que fornece os métodos disponíveis no objeto passado pelo <tt>create_table</tt>) e  <a href="http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/Table.html">ActiveRecord::ConnectionAdapters::Table</a> (que fornece os métodos disponíveis no objeto passado pelo <tt>change_table</tt>).</p>
<h4 id="escrevendo-o-seu-mtodo-down--parei-aqui---adolfo-">3.4 Escrevendo o seu Método <tt>down</tt> <b>* <span class="caps">PAREI</span> <span class="caps">AQUI</span> &#8211; Adolfo *</b></h4>
<p>O método <tt>down</tt> da sua migration deve reverter as transformações concluídas pelo método <tt>up</tt>. Em outras palavras, o banco de dados deve se manter inalterado se você fizer um <tt>up</tt> seguido de um <tt>down</tt>. Por exemplo, se você criar uma tabela no método up você deverá excluí-la no método <tt>down</tt>. Deve ser sábio e precisamente inverso ao método <tt>up</tt>. Por exemplo</p>
<div class="code_container"><code class="ruby">
class ExampleMigration &lt; ActiveRecord::Migration

  def self.up
    create_table :products do |t|
      t.references :category
    end
    #add a foreign key
    execute &quot;ALTER TABLE products ADD CONSTRAINT fk_products_categories FOREIGN KEY (category_id) REFERENCES categories(id)&quot;
    
    add_column :users, :home_page_url, :string
    
    rename_column :users, :email, :email_address
  end
  
  def self.down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
    execute &quot;ALTER TABLE products DROP FOREIGN KEY fk_products_categories&quot;
    drop_table :products
  end
end
</code></div>
<p>Algmas vezes a sua migration pode fazer algumas coisas irreversíveis, por exemplo quando você destrói alguns dados. Em casos como esse onde você não pode reverter uma migration, você pode lançar IrreversibleMigration para o seu método <tt>down</tt>. Se alguém tentar reverter a sua migration uma mensagem será mostrada falando que ela não será completa.
displayed saying that it can&#8217;t be done.</p>
<h3 id="executando-migraes">4 Executando migrações</h3>
<p>Rails fornece um conjunto de tarefas rake para trabalhar com as migrações, que se resume em rodar alguns conjuntos de migrações. A tarefa rake mais relatada que você provavelmente usará é <tt>db:migrate</tt>. Na sua forma mais básica certamente rodará o método <tt>up</tt> para todas as migrações que ainda não foram rodadas. Se não existir migrações ele sai.</p>
<p>Se você especificar uma migration, o Active Record irá rodar as migrações requeridas (up ou down) até que ela tenha chegado nessa versão específica. A versão é o prefixo numérico do nome de uma migration. Por exemplo para migrar até a versão 20080906120000 execute</p>
<pre>
rake db:migrate VERSION=20080906120000
</pre>
<p>Se a versão for maior do que a versão corrente (ou seja, está migrando para cima) irá rodar o método <tt>up</tt> de em todas as migrações acima e incluindo a versão 20080906120000, se a migration for para baixo, então será executado os métodos <tt>down</tt> de todas as migrações para baixo até, mas não incluindo, 20080906120000.</p>
<h4 id="reverso">4.1 Reversão</h4>
<p>Uma tarefa comum é regressar a última migration, por exemplo, se você cometeu um engano e deseja corrigi-lo. Ao invés de monitorar o método down com a migration anterior, você pode rodar</p>
<pre>
rake db:rollback
</pre>
<p>Isso irá rodar o método <tt>down</tt> da migration mais recente. Se você precisa se desfazer de várias migrações, você pode fornecer o parâmetro <tt>STEP</tt>:</p>
<pre>
rake db:rollback STEP=3
</pre>
<p>irá rodar o método <tt>down</tt> das 3 últimas migrações.</p>
<p>A tarefa <tt>db:migrate:redo</tt> é um atalho para fazer uma reversão e a migration de volta. Assim como na tarefa <tt>db:rollback</tt> você pode usar o parâmetro <tt>STEP</tt> se você precisar voltar em mais de uma versão, por exemplo</p>
<pre>
rake db:migrate:redo STEP=3
</pre>
<p>Nenhuma dessas tarefas Rake fazem qualquer coisa que você não poderia fazer com <tt>db:migrate</tt>, são simplesmente mais convenientes, desde que você não precise explicitamente especificar a versão de uma migration para outra.</p>
<p>Finalmente, a tarefa <tt>db:reset</tt> irá destruir sua base de dados, recria-la e carregar o schema atual dentro dela.</p>
<div class='note'><p>Isto não é o mesmo que você rodar todas as migrações &#8211; veja a seção <a href="#armazenando-esquemas-e-voc">schema.rb</a></p></div>
<h4 id="especificando-uma-migration">4.2 Especificando uma migration</h4>
<p>Se você precisa especificar uma migration para cima ou para baixo, as tarefas <tt>db:migrate:up</tt> e <tt>db:migrate:down</tt> irão fazer isso. Basta especificar a versão apropriada e a migration correspondente e terá seu método <tt>up</tt> ou <tt>down</tt> invocado, por exemplo</p>
<pre>
rake db:migrate:up VERSION=20080906120000
</pre>
<p>irá rodar o método <tt>up</tt> da migration 20080906120000. Estas tarefas checa se a migration já tenha sido executada, se por exemplo <tt>db:migrate:up VERSION=20080906120000</tt> não irá fazer nada se o Active Record acreditar que 20080906120000 já tenha sido executada.</p>
<h4 id="sendo-comunicativo">4.3 Sendo comunicativo</h4>
<p>Por padrão, as migrações falam exatamente o que elas estão fazendo e o tempo de duração. Uma migration criando uma tabela e adicionando um index produz uma saída como esta</p>
<div class="code_container"><code class="html">
20080906170109 CreateProducts: migrating
-- create_table(:products)
   -&gt; 0.0021s
-- add_index(:products, :name)
   -&gt; 0.0026s
20080906170109 CreateProducts: migrated (0.0059s)
</code></div>
<p>Vários método fornecem para você o controle tudo isto:</p>
<ul>
	<li><tt>suppress_messages</tt> suprime qualquer mensagem gerada pelo bloco</li>
	<li><tt>say</tt> saída de texto (o segundo argumento controle se é recortado ou não)</li>
	<li><tt>say_with_time</tt> saída de texto com o tempo utilizado pelos blocos. Se o bloco retornar um inteiro, assume-se que este é o número de linhas afetadas.</li>
</ul>
<p>For example, esta migration</p>
<div class="code_container"><code class="ruby">
class CreateProducts &lt; ActiveRecord::Migration
  def self.up
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end
    say &quot;Created a table&quot;
    suppress_messages {add_index :products, :name}
    say &quot;and an index!&quot;, true
    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end

  def self.down
    drop_table :products
  end
end
</code></div>
<p>gerará a seguinte saída</p>
<div class="code_container"><code class="html">
20080906170109 CreateProducts: migrating
  Created a table
   -&gt; and an index!
  Waiting for a while
   -&gt; 10.0001s
   -&gt; 250 rows
20080906170109 CreateProducts: migrated (10.0097s)
</code></div>
<p>Se você quiser que o Active Record mantenha-se em silêncio, então execute <tt>rake db:migrate VERBOSE=false</tt> e irá suprimir qualquer saída.</p>
<h3 id="usando-models-nas-suas-migraes">5 Usando models nas suas migrações</h3>
<p>Ao criar ou atualizar dados na sua migration, muitas vezes, é tentador utilizar um de seus models. Afinal eles existem para fornecer acesso fácil nos dados subjacentes. Isto pode ser feito mas um certo cuidado devem ser observados.</p>
<p>Considere por exemplo a migration que usa o modelo Product para atualizar a linha na tabela correspondente. Alice depois atualiza o modelo Product, adicionando uma nova coluna e uma validação. Bob volta do feriado, atualiza o código e roda as migrações pendentes com <tt>rake db:migrate</tt>, incluindo o modelo que é utilizado para o Product. Quando o código é atualizado e só então o modelo Product possui a validação adicionada pela Alice. O banco de dados entretanto não é atualizado e assim não possui a coluna e então gerará um erro, por que a validação para esta coluna ainda não existe.</p>
<p>Frequentemente eu preciso atualizar as linhas no banco de dados sem escrever <span class="caps">SQL</span> pelas minhas mãos. Eu não estou usando qualquer especialidade do modelo. Um padrão para isso é definir uma cópia do modelo dentro da própria migration, por exemplo</p>
<div class="code_container"><code class="ruby">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  class Product &lt; ActiveRecord::Base
  end
  
  def self.up
    ...
  end

  def self.down
    ...
  end
end
</code></div>
<p>A migration possuirá uma própria copia mínima do modelo Product e não mais precisará saber sobre o modelo Product definido na própria aplicação.</p>
<h4 id="lidando-com-mudanas-nos-modelos">5.1 Lidando com mudanças nos modelos</h4>
<p>Por razões de performance, as informações sobre as colunas de um modelo são cacheadas. Por exemplo, se você adicionar a coluna na tabela e tentar usar o modelo correspondente para inserir uma nova linha, ele pode tentar usar as informações antigas. Você pode forçar o Active Record para reler a informação da coluna com o método <tt>reset_column_information</tt>, por exemplo</p>
<div class="code_container"><code class="ruby">
class AddPartNumberToProducts &lt; ActiveRecord::Migration
  class Product &lt; ActiveRecord::Base
  end
  
  def self.up
    add_column :product, :part_number, :string
    Product.reset_column_information
    ...
  end

  def self.down
    ...
  end
end
</code></div>
<h3 id="armazenando-esquemas-e-voc">6 Armazenando esquemas e você</h3>
<h4 id="quais-so-os-arquivos-do-esquema">6.1 Quais são os arquivos do esquema?</h4>
<p>Migrações, poderosas como são, não são fontes autorizada para o esquema do seu banco de dados. Esse papel cabe ao <tt>schema.rb</tt> ou ao um arquivo <span class="caps">SQL</span> gerado pelo Active Record através da análise do banco de dados. Este arquivo não foi projetado para ser editado, ele é uma representação do estado atual do banco de dados.</p>
<p>Não é necessário (e isto é um erro propenso) para implantar uma nova instancia de uma aplicação repetindo o histórico inteiro da migration. É mais simples e rápido apenas carregar dentro do banco de dados a descrição do esquema atual.</p>
<p>Por exemplo, esta é a forma de como o banco de dados de testes é criado: o banco de dados atual de desenvolvimento é excluído (tanto para o <tt>schema.rb</tt> ou para <tt>development.sql</tt>) e então carregado dentro do banco de dados de teste.</p>
<p>Arquivos de esquema também são uteis se deseja olhar rapidamente quais atributos o objeto do Active Record possui. Estas informações não está no código do modelo e frequentemente está espalhado pelas várias migrations mas está resumido no arquivo de esquema. O plugin <a href="http://agilewebdevelopment.com/plugins/annotate_models">annotate_models</a>, adiciona automaticamente cada (e atualiza) os comentários no início de cada model resumindo o esquema, que pode ser de seu interesse.</p>
<h4 id="formas-de-armazenar-o-esquema">6.2 Formas de armazenar o esquema</h4>
<p>Existe duas formas de armazenar o esquema. Uma é setar em <tt>config/environment.rb</tt> atribuindo o <tt>config.active_record.schema_format</tt>, que pode ser <tt>:sql</tt> ou <tt>:ruby</tt>.</p>
<p>Se <tt>:ruby</tt> é selecionada então o esquema será armazenado em <tt>db/schema.rb</tt>. Se você olhar este arquivo você verá que não encontrará um pouco mais do que uma grande migration:</p>
<div class="code_container"><code class="ruby">
ActiveRecord::Schema.define(:version =&gt; 20080906171750) do
  create_table &quot;authors&quot;, :force =&gt; true do |t|
    t.string   &quot;name&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
  end

  create_table &quot;products&quot;, :force =&gt; true do |t|
    t.string   &quot;name&quot;
    t.text     &quot;description&quot;
    t.datetime &quot;created_at&quot;
    t.datetime &quot;updated_at&quot;
    t.string   &quot;part_number&quot;
  end
end
</code></div>
<p>De muitas formas é exatamente isso. Este arquivo é criado pela examinação do banco de dados e expressado em estruturas usando <tt>create_table</tt>, <tt>add_index</tt> e assim por diante. Por causa da independência do banco de dados ele deve carregar dentro de qualquer banco de dados que o Active Record suporta. Isso poderia ser muito útil se você quiser distribuir a aplicação para rodar em vários banco de dados.</p>
<p>Existe porém uma desvantagem: <tt>schema.rb</tt> não expressa itens específicos de banco de dados como constraints de chaves estrangeiras, triggers ou stored procedures. Enquanto na migration você pode executar <span class="caps">SQL</span> customizadas, o esquema armazenado não pode reconstituir essas atribuições do banco de dados. Se você usar recursos como este, então você deve atribuir o esquema para <tt>:sql</tt>.</p>
<p>Em vez de usar o esquema de armazenamento do Active Record a estrutura será armazenada usando uma ferramenta específica do banco de dados (pela tarefa rake <tt>db:structure:dump</tt>) dentro de <tt>db/#\{RAILS_ENV\}_structure.sql</tt>. Por exemplo para o PostgreSQL a utilidade <tt>pg_dump</tt> é usada e para o MySQL este arquivo irá conter a saída de <span class="caps">SHOW</span> <span class="caps">CREATE</span> <span class="caps">TABLE</span> para as várias tabelas. Carregando este esquema é uma simples questão de executar as declarações <span class="caps">SQL</span> contida dentro.</p>
<p>Por definição irá fazer uma copia perfeita da estrutura do banco de dados mas isso vai impedir o carregamento do esquema dentro de outros banco de dados que não seja um dos utilizados para criá-lo.</p>
<h4 id="armazenamento-de-esquema-e-controle-de-cdigo">6.3 Armazenamento de esquema e controle de código</h4>
<p>Por causa da autoridade do código do seu esquema de banco de dados, é altamente recomendado que você verifique dentro de seu controle de código.</p>
<h3 id="active-record-e-integridade-referencial">7 Active Record e Integridade Referencial</h3>
<p>O Active Record é a maneira inteligente de permanecer em seus modelos, não no banco de dados. Alguns recursos como triggers ou constraints de chaves estrangeiras, que empurra alguma inteligência de volta para os banco de dados não são muito usados.</p>
<p>Validações como <tt>validates_uniqueness_of</tt> é uma forma de seus modelos podem valer a integridade dos dados. A opção <tt>:dependent</tt> em associações adiciona aos modelos automaticamente destruir os objetos filhos que seus pais são destruídos. Como tudo que funciona a nível de aplicação, estes não podem garantir integridade referencial e algumas pessoas aumentam com constraints de chaves estrangeiras.</p>
<p>Apesar de o Active Record não fornecer todas as ferramentas para trabalhar diretamente com todos os recursos, o método <tt>execute</tt> pode ser usado para executar <span class="caps">SQL</span> arbitrárias. Há também uma série de plugins como <a href="http://agilewebdevelopment.com/plugins/search?search=redhillonrails">redhillonrails</a> que adicionam suporte a chaves estrangeiras para o Active Record (incluindo suporte para destruir chaves estrangeiras no <tt>schema.rb</tt>)</p>
<h3 id="changelog">8 Changelog</h3>
<p><a href="http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/6">Lighthouse ticket</a></p>
<ul>
	<li>10 de Novembro de 2008: traduzido por <a href="credits.html#caironoleto">Cairo Noleto</a></li>
</ul>
<ul>
	<li>14 de Setembro de 2008: versão inical por <a href="credits.html#fcheung">Frederick Cheung</a></li>
</ul>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>Autores que contribuíram para guias completos estão listados <a href="credits.html">aqui</a>.<br />
        Tradutores que contribuíram na tradução dos guias originais para Língua Portuguesa estão listados <a href="translators.html">aqui</a>.<br />
        Este trabalho está licenciado sob a licença <a href="http://creativecommons.org/licenses/by-sa/3.0">Creative Commons Attribution-Share Alike 3.0</a>.</p>
      <p>"Rails", "Ruby on Rails", e o logo do Rails são marcas registradas de David Heinemeier Hansson. Todos os direitos reservados.</p>
    </div>
  </div>
</body>
</html>
