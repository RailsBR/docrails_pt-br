h2. O Guia de Associações do Active Record

Este guia aborda as características de associação do ActiveRecord. Ao estudar este guia, você será capaz de:

* Declarar associações entre models do ActiveRecord
* Compreender os diferentes tipos de associações do ActiveRecord
* Utilizar os métodos adicionados aos seus models ao criar associações

endprologue.

h3. Associações, por quê?

Por que precisamos de associações entre models? Porque elas tornam mais fácil e mais simples operações comuns no código. Considere, por exemplo, uma simples aplicação Rails que inclui um model para clientes (Customer) e um model para encomendas (Order). Cada cliente pode ter muitas encomendas. Sem as associações, a declaração dos models seria parecida com isto:

<ruby>
class Customer < ActiveRecord::Base
end

class Order < ActiveRecord::Base
end
</ruby>

Agora, suponha que quiséssemos acrescentar uma nova encomenda a um cliente existente. Precisaríamos fazer algo parecido com isto:

<ruby>
@order = Order.create(:order_date => Time.now, :customer_id => @customer.id)
</ruby>

Ou quiséssemos apagar um cliente, e garantir que todas as suas encomendas fossem excluídas também:

<ruby>
@orders = Order.find_by_customer_id(@customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
</ruby>

Com as associações do ActiveRecord, podemos simplificar estas -- e outras -- operações dizendo declarativamente ao Rails que existe uma conexão entre os dois models. Veja abaixo o código revisado para a declaração de clientes e encomendas:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :destroy
end

class Order < ActiveRecord::Base
  belongs_to :customer
end
</ruby>

Com esta mudança, criar uma nova encomenda para um cliente é mais fácil:

<ruby>
@order = @customer.orders.create(:order_date => Time.now)
</ruby>

Remover um cliente e todas as suas encomendas é _muito_ mais fácil:

<ruby>
@customer.destroy
</ruby>

Para saber mais sobre os diferentes tipos de associações, leia a próxima seção deste guia. Ela contém também alguns truques e dicas para trabalhar com as associações, e ao seu final se encontra uma referência completa para os métodos e opções para associações em Rails.

h3. Os tipos de associações

Em Rails, uma _associação_ é uma conexão entre os dois models do ActiveRecord. Associações são implementadas usando macros de chamadas, de modo que você pode adicionar declarativamente funcionalidades aos seus models. Por exemplo, declarando que um model +belongs_to+ (pertence a) outro, você instrui o Rails a manter informações de Chave Primária - Chave Estrangeira entre instâncias dos dois models, além de receber alguns métodos úteis em seu model. O Rails suporta seis tipos de associação:

* +belongs_to+ (pertence a)
* +has_one+ (possui um)
* +has_many+ (possui muitos)
* +has_many :through+ (possui muitos através de)
* +has_one :through+ (possui um através de)
* +has_and_belongs_to_many+ (possui e pertence a muitos)

No restante deste guia, você aprenderá a declarar e utilizar as diversas formas de associações. Mas, primeiro, uma introdução rápida a situações em que cada tipo de associação é adequado.

h4. A associação +belongs_to+

Uma associação +belongs_to+ cria uma conexão um-para-um com outro model, de modo que cada instância do model _“pertença a”_ (+belongs_to+) uma instância de um outro model. Por exemplo, se sua aplicação incluir clientes (Customer) e encomendas (Orders), e cada encomenda possa set atribuída a somente um cliente, você declararia o model desta forma:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer
end
</ruby>

!images/belongs_to.png(belongs_to Association Diagram)!

h4. A associação +has_one+

A associação +has_one+ também configura uma conexão um-para-um com outro model, mas com uma semântica (e consequências) um pouco diferente. Esta associação indica que cada instância de um model contém ou possui uma instancia de outro model. Por exemplo, se cada fornecedor (Supplier) na sua aplicação possui somente uma conta (Account), você poderia declarar o model fornecedor desta forma:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account
end
</ruby>

!images/has_one.png(has_one Association Diagram)!

h4. A associação +has_many+

Uma associação +has_many+ indica uma conexão um-para-muitos com outro model. Você irá encontrar frequentemente esta associação do _“outro lado”_ de uma associação +belongs_to+. Esta associação indica que cada instância do model possui zero ou mais instâncias do outro model. Por exemplo, em uma aplicação contendo clientes (Customer) e encomendas (Orders), o model cliente poderia ser declarado assim:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

NOTE: O nome do outro model é pluralizado quando se está declarando uma associação +has_many+.

!images/has_many.png(has_many Association Diagram)!

h4. A Associação +has_many :through+

Uma associação +has_many :through+ é frequentemente utilizada para criar um conexão muitos-para-muitos com outro model. Esta associação indica que o model pode possuir zero ou mais instâncias de outro model _“através de”_ (+trough+) um terceiro model. Por exemplo, considere uma prática médica onde pacientes (Patient) podem marcar consultas (Appointment) com médicos (Physician). As declarações da associação seriam semelhantes a esta:

<ruby>
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, :through => :appointments
end

class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, :through => :appointments
end
</ruby>

!images/has_many_through.png(has_many :through Association Diagram)!

A associação +has_many :through+ é também útil para a criação de _“atalhos”_ através de associações +has_many+ aninhadas. Por exemplo, se um documento tem várias seções, e uma seção possui vários parágrafos, você pode querer recuperar uma simples coleção de todos os parágrafos no documento. Você poderia declarar desta forma:

<ruby>
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, :through => :sections
end

class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ActiveRecord::Base
  belongs_to :section
end
</ruby>

h4. A associação +has_one: through+

Uma associação +has_one :through+ cria uma conexão de um-para-um com outro model. Esta associação indica que um model pode estar associado uma instância de outro model _através_ de um terceiro model. Por exemplo, se cada fornecedor (Supplier) possui uma conta (Account), e cada conta está associada a um histórico de conta (AccountHistory), então o model cliente poderia ser declarado desta forma:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, :through => :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ActiveRecord::Base
  belongs_to :account
end
</ruby>

!images/has_one_through.png(has_one :through Association Diagram)!

h4. A associação +has_and_belongs_to_many+

Uma associação +has_and_belongs_to_many+ cria uma conexão direta muitos-para-muitos com outro model, sem um outro model intervindo. Por exemplo, se a sua aplicação incluir peças (Parts) e conjuntos (Assemblies), onde cada conjunto inclui várias peças e que cada peça aparece em muitos conjuntos, você poderia declarar os models desta maneira:

<ruby>
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
</ruby>

!images/habtm.png(has_and_belongs_to_many Association Diagram)!

h4. Escolhendo entre +belongs_to+ e +has_one+

Se você deseja criar uma relação 1-1 entre dois models, será necessário adicionar a um +belongs_to+ e ao outro +has_one+. Como você sabe qual é qual?

A distinção está no lugar onde você colocou a chave estrangeira (ela fica na tabela da classe que foi declarada a associação +belongs_to+), mas você deveria refletir um pouco sobre o real significado dos dados. O relacionamento +has_one+ diz que alguma coisa é sua - ou seja, que algo aponta para você. Por exemplo, faz mais sentido dizer que um fornecedor possui uma conta do que uma conta que possui um fornecedor. Isso sugere que o relacionamento correto é algo como este:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
end
</ruby>

A migration correspondente seria assim:

<ruby>
class CreateSuppliers < ActiveRecord::Migration
  def self.up
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end

  def self.down
    drop_table :accounts
    drop_table :suppliers
  end
end
</ruby>

NOTE: Usar +t.integer :supplier_id+ faz a nomeação da chave estrangeira óbvia e explícita. Nas versões atuais do Rails, você pode abstrair a implementação deste detalhe usando +t.references :supplier+.

h4. Escolhendo entre +has_many :through+ e +has_and_belongs_to_many+

O Rails oferece duas maneiras diferentes para declarar um relacionamento muitos-para-muitos entre models. A maneira mais simples é usar +has_and_belongs_to_many+, que permite que você faça a associação diretamente:

<ruby>
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
</ruby>

A segunda forma de declarar um relacionamento muitos-para-muitos é usar +has_many :through+. Isto criará uma associação indireta, através de um model que realizará o join:

<ruby>
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, :through => :manifests
end

class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, :through => :manifests
end
</ruby>

A regra simples é que você deve criar um relacionamento +has_many :through+ se você precisar trabalhar com o model de relacionamento como uma entidade independente. Se você não precisar fazer nada com o model de relacionamento, pode ser mais simples criar um relacionamento +has_and_belongs_to_many+ (mas lembre-se que ainda assim você precisa criar as tabelas de joins).

Você deve usar +has_many :through+ se você precisar de validações, callbacks, ou atributos extras no model de join.

h4. Associações polimórficas

Um ponto mais avançado sobre associações são as _associações polimórficas_. Com associações polimórficas, um model pode pertencer a mais de um model, em uma única associação. Por exemplo, você pode ter um model foto que pertence a um model empregado ou a um model produto. Aqui está como isso pode ser declarado:

<ruby>
class Picture < ActiveRecord::Base
  belongs_to :imageable, :polymorphic => true
end

class Employee < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end

class Product < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end
</ruby>

Você pode pensar em uma declaração +belongs_to+ polimórfica como sendo uma interface que pode ser usada por qualquer outro model. A partir de uma instância do model +Employee+, você pode recuperar uma coleção de fotos: +@employee.pictures+. 

Da mesma forma, você pode usar +@product.pictures+. 

Se você tem uma instância do model Picture, você pode recuperar seu pai através de +@picture.imageable+. Para que isto funcione, você deve declarar uma coluna de chave estrangeira e uma coluna de tipo no model que declara a interface polimórfica:

<ruby>
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
</ruby>

Esta migration pode ser simplificada utilizando a forma +t.references+:

<ruby>
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
</ruby>

!images/polymorphic.png(Polymorphic Association Diagram)!

h4. Auto-associações

Ao desenhar seu modelo de dados, às vezes você precisará de um model que terá uma relação consigo mesmo. Por exemplo, você pode querer armazenar todos os empregados em um único model no banco de dados, e pode querer poder rastrear relacionamentos entre gerentes e subordinados. Esta situação pode ser modelada utilizando auto-associações:

<ruby>
class Employee < ActiveRecord::Base
  has_many :subordinates, :class_name => "Employee", :foreign_key => "manager_id"
  belongs_to :manager, :class_name => "Employee"
end
</ruby>

Com essa configuração, você pode utilizar +@employee.subordinates+ e +@employee.manager+.

h3. Dicas, truques e avisos

Aqui estão algumas coisas que você deve saber para fazer um uso eficiente das associações do Active Record em suas aplicações Rails:

* Controlando caching
* Evitando colisões com nomes
* Atualizando o schema
* Controlando o escopo das associações

h4. Controlando caching

Todos os métodos de associação são construídos em torno de um caching que mantém o resultado das queries recentes disponíveis para futuras operações. O cache é compartilhado até mesmo entre métodos. Por exemplo:

<ruby>
customer.orders                 # retorna todas as orders (encomendas) do banco de dados
customer.orders.size            # usa a cópia no cache de orders
customer.orders.empty?          # usa a cópia no cache de orders
</ruby>

Mas e se você quiser recarregar o cache, porque seus dados foram alterados em outra parte da aplicação? Apenas passe +true+ para a chamada da associação:

<ruby>
customer.orders                 # retorna todas as orders (encomendas) do banco de dados
customer.orders.size            # usa a cópia no cache de orders
customer.orders(true).empty?    # desconsidera a cópia do cache e faz a busca no banco de dados novamente
</ruby>

h4. Evitando colisões com nomes

Você não é livre para usar qualquer nome para suas associações. Como ao criar uma associação é criado um método com o nome da associação no model, é uma má idéia dar a associação um nome que já está sendo usado por um método de instância no +ActiveRecord::Base+ . O método de associação iria sobrescrever o método inicial e quebrar as coisas. Então, +attributes+ ou +connection+ são nomes ruins para associações.

h4. Atualizando o schema

Associações são extremamente úteis, mas não são mágicas. Você é responsável por manter seu esquema do banco de dados sincronizado com suas associações. Na prática, isto significa duas coisas, dependendo do tipo de associação que você está criando. Para associações belongs_to você precisará criar as chaves estrangeiras, e para associações has_and_belongs_to_many você deverá criar a tabela de junção.

h5. Criando chaves estrangeiras para associações belongs_to

Quando você declara um associação belongs_to, você deve criar as chaves estrangeiras apropriadas. Por exemplo, considere este model:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer
end
</ruby>

Esta declaração deve ser feita em conjunto com a declaração da chave estrangeira na tabela orders:

<ruby>
class CreateOrders < ActiveRecord::Migration
  def self.up
    create_table :orders do |t|
      t.datetime :order_date
      t.string   :order_number
      t.integer  :customer_id
    end
  end

  def self.down
    drop_table :orders
  end
end
</ruby>

Se você criar uma associação depois de um tempo da criação do model, você deve lembrar-se de criar uma migration com  um add_column para criar a chave estrangeira necessária.

h5. Criando tabelas de junção para associações has_and_belongs_to_many

Se você criar uma associação has_and_belongs_to_many, você deverá explicitamente criar uma tabela de junção. A não ser que o nome da tabela de junção esteja explicitamente especificado na opção :join_table, o ActiveRecord cria o nome a partir da ordem alfabética dos nomes das classes. Então, uma junção entre os models customer e order irá criar o nome de junção padrão "customers_orders", porque "c" vem antes de "o" na ordem alfabética.

WARNING: A precedência entre nomes de models é calculada utilizando o operador +<+ da classe +String+. Isto significa que se as strings são de tamanhos diferentes, e as strings são iguais quando comparadas com a menor parte, então a string maior é considerada de maior precedência na ordem alfabética. Por exemplo, você poderia pensar que as tabelas "paper_boxes" e "papers" gerariam uma tabela de junção chamada "papers_paper_boxes" por causa do tamanho do nome "paper_boxes", mas na verdade o nome gerado será "paper_boxes_papers" (porque o sublinhado '_' é alfabéticamente _menor_ do que o 's' nas codificações comuns).

Seja qual for o nome, você deve manualmente criar uma tabela de junção com uma migration apropriada. Por exemplo, considere esta associação:

<ruby>
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
</ruby>

Ela precisa de uma migration que crie a tabela +assemblies_parts+. Esta tabela deve ser criada sem uma chave primária:

<ruby>
class CreateAssemblyPartJoinTable < ActiveRecord::Migration
  def self.up
    create_table :assemblies_parts, :id => false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end

  def self.down
    drop_table :assemblies_parts
  end
end
</ruby>

Nós passamos +:id => false+ para +create_table+ por que esta tabela não representa um model. Isto é obrigatório para a associação funcionar corretamente. Se você observar algum comportamento estranho em uma associação +has_and_belongs_to_many+ como models faltando IDs, ou exceções sobre IDs conflitantes existem boas chances de você ter esquecido este detalhe.

h4. Controlando o escopo das associações

Por padrão, associações procuram por objetos apenas no escopo do módulo atual. Isto pode ser importante quando você declara models Active Record dentro de um módulo. Por exemplo:

<ruby>
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end

    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
</ruby>

Isto irá funcionar, porque tanto a classe +Supplier+ quanto a classe +Account+ estão definidas no mesmo escopo. Mas o código abaixo não funcionará, porque +Supplier+ e +Account+ estão definidos em escopos diferentes:

<ruby>
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
</ruby>

Para associar um model a outro model em um namespace diferente, você precisa especificar o nome completo da classe na declaração de sua associação:

<ruby>
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account, :class_name => "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier, :class_name => "MyApplication::Business::Supplier"
    end
  end
end
</ruby>

h3. Referência Detalhada sobre Associações

As seções seguintes detalham cada tipo de associação, incluindo métodos que elas adicionam e as opções que você pode usar quando estiver declarando uma associação.

h4. Referência da associação +belongs_to+

A associação +belongs_to+ (pertence a) cria uma dependência de um-para-um com outro model. Em termos de banco de dados, esta associação diz que esta classe contém a chave estrangeira. Se a outra classe contiver a chave estrangeira, você deverá usar +has_one+ ao invés de +belongs_to+.

h5. Métodos adicionados pelo +belongs_to+

Quando você declara uma associação +belongs_to+, a classe declarada automaticamente ganha quatro métodos relacionados a associação:

* <tt><em>association</em>(force_reload = false)</tt>
* <tt><em>association</em>=(associate)</tt>
* <tt>build_<em>association</em>(attributes = {})</tt>
* <tt>create_<em>association</em>(attributes = {})</tt>

Em todos estes métodos, +<tt><em>association</em></tt>+ é substituído pelo símbolo passado como primeiro argumento ao +belongs_to+. Por exemplo:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer
end
</ruby>

Cada instância do model order vai ter estes métodos:

<ruby>
customer
customer=
build_customer
create_customer
</ruby>

h6. <tt><em>association</em></tt>(force_reload = false)

O método +<tt><em>association</em></tt>+ returna o objeto associado, se existir. Se nenhum objeto associado for encontrado então, seu retorno será +nil+ .

<ruby>
@customer = @order.customer
</ruby>

Se o objeto associado já tiver sido buscado no banco de dados para este objeto, o valor em cache será retornada. Para substituir esse comportamento (e forçar o banco de dados a reler), passe +true+ no argumento +force_reload+ .

h6. _association_=(associate)+

O método +<tt><em>association</em></tt>=+ atribui um objeto associado para este objeto. Nos bastidores, isto significa buscar a chave primária do objeto associado e definir a chave estrangeira deste objeto para o mesmo valor.

<ruby>
@order.customer = @customer
</ruby>

h6. build_<em>association</em>(attributes = {})

O método <tt>build_<em>association</em></tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, a associação a este objeto através da chave estrangeira será definida, mas o objeto associado ainda não será salvo.

<ruby>
@customer = @order.build_customer(:customer_number => 123,
  :customer_name => "John Doe")
</ruby>

h6. create_<em>association</em>(attributes = {})

O método <tt>build_<em>association</em></tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, a associação a este objeto através da chave estrangeira será definida. Adicionalmente,  o objeto associado será salvo (assumindo que passe pelas validações).

<ruby>
@customer = @order.create_customer(:customer_number => 123,
  :customer_name => "John Doe")
</ruby>

h5. Opções para belongs_to

Em muitas situações, você pode usar o comportamento padrão do +belongs_to+ sem nenhuma customização. Mas apesar da ênfase do Rails em convenção sobre customização, você poder alterar este comportamento de várias formas. Esta sessão cobre as opções que você pode passar quando criar uma associação +belongs_to+. Por exemplo, uma associação com várias opções pode parecer com isto:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true, :conditions => "active = 1"
end
</ruby>

A associação +belongs_to+ suporta estas opções:

* +:autosave+
* +:class_name+
* +:conditions+
* +:counter_cache+
* +:dependent+
* +:foreign_key+
* +:include+
* +:polymorphic+
* +:readonly+
* +:select+
* +:validate+

h6. :autosave

Se você definir a opção +:autosave+ como +true+, o Rails irá salvar quaisquer membros carregados e destruir membros que estejam marcados para serem destruídos sempre que você salvar o objeto que possui as associações.

h6. :class_name

Se o nome do outro model não puder ser derivado do nome da associação, você pode usar a opção +:class_name+ para informar o nome do model. Por exemplo, se uma "order" pertence a um "customer", mas o nome atual do model que contém "customer" é +Patron+, você deve definir desta forma:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron"
end
</ruby>

h6. :conditions

A opção +:conditions+ permite que você especifique as condições que o objeto associado precisa cumprir (na sintaxe usada por uma cláusula SQL +WHERE+ ).

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :conditions => "active = 1"
end
</ruby>

h6. :counter_cache

A opção +:counter_cache+ pode ser usada para fazer a busca do número de objetos associados mais eficiente. Considere estes models:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

Com estas declarações, pedindo o valor +@customer.orders.size+ requer uma chamada para o banco de dados para executar uma query +COUNT(*)+ . Para evitar esta chamada, você pode adicionar um contador em cache ao model pertencente:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true
end
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

Com estas declarações, o Rails vai manter o valor no cache atualizado, e então retornar o valor como resposta ao método +size+ .

Apesar da opção +:counter_cache+ ser especificada no model que inclui a declaração +belongs_to+, uma coluna precisa ser adicionada ao model _associado_ . No caso acima, você deveria adicionar uma coluna +orders_count+ ao model +Customer+. Você pode sobrescrever o nome padrão da coluna se você precisar:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

Colunas de contador em cache são adicionadas ao model que as contém como atributos somente leitura através de +attr_readonly+.

h6. :dependent

Se você definir a opção +:dependent+ para +:destroy+, então excluindo este objeto será chamado o método destroy no objeto associado para destruir o objeto. Se você definir a opção +:dependent+ para +:delete+, então excluindo este objeto irá excluir o objeto associado _sem_ chamar o método +destroy+.

WARNING: Você não deve especificar esta opção em uma associação +belong_to+ que esteja conectada com uma associação +has_many+ na outra classe. Fazer isto pode resultar em registros orfãos em seu banco de dados.

h6. :foreign_key

Por convenção, o Rails adivinha que a coluna que será usada para guardar a chave estrangeira neste model será o nome da associação com o sufixo +_id+. A opção +:foreign_key+ permite que você defina o nome da chave estrangeira diretamente:

<ruby>
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron", :foreign_key => "patron_id"
end
</ruby>

TIP: Em nenhum caso o Rails irá criar as colunas de chave estrangeira para você. Você precisa explicitamente definí-las como parte de suas migrations.

h6. :include

Você pode usar a opção :include para especificar as associações de segunda ordem que devem ser pré-carregadas quando esta associação for utilizada. Por exemplo:

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

Se você frequentemente recupera customers diretamente de line items (+@line_item.order.customer+), então você pode fazer seu código um pouco mais eficiente incluindo customers na associação de line items para orders:

<ruby>
class LineItem < ActiveRecord::Base
  belongs_to :order, :include => :customer
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

NOTE: Não há necessidade de usar +:include+ para associações imediatas - isto significa que, se você tiver +Order belongs_to :customer+, então customer é pré-carregado automaticamente quando for necessário.

h6. :polymorphic

Passando +true+ para a opção +:polymorphic+ indica que esta será uma associação polimórfica. Associações polimórficas foram discutidas em detalhes "anteriormente neste guia":#associaes-polimrficas.

h6. :readonly

Se você definir a opção +:readonly+ para +true+, então o objeto associado terá acesso somente leitura quando for retornado pela associação.

h6. :select

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que é usada para retornar dados sobre o objeto associado. Por padrão, o Rails retorna todas as colunas.

TIP: Se você definir a opção +:select+ em uma associação +belongs_to+ , você também deve definir a opção +foreign_key+ para garantir resultados corretos.

h6. :validate

Se você definir a opção +:validate+ para +true+, então os objetos associados serão validados sempre que você salvar este objeto. Por padrão, esta opção é +false+: objetos associados não serão validados quando este objeto for gravado.

h5. Como saber se existe um objeto associado?

Para saber se existe um objeto associado, simplesmente verifique a associação com association.nil?:

<ruby>
if @order.customer.nil? 
  @msg = "No customer found for this order" 
end 
</ruby>

h5. Quando objetos são gravados?

Atribuir um objeto a uma associação +belongs_to+ _não_ o grava automaticamente. Também não grava o objeto associado. 

h4. Referência da associação +has_one+

A associação +has_one+ cria uma relação um-para-um com outro model. Em termos de banco de dados, esta associação diz que a outra classe terá a chave estrangeira. Se esta classe possuir a chave estrangeira, então você deve usar um +belongs_to+.

h5. Métodos Adicionados pelo +has_one+

Quando você declara a associação +has_one+, a classe declarante automaticamente ganha quatro métodos relacionados a associação:

* <tt><em>association</em>(force_reload = false)</tt>
* <tt><em>association</em>=(associate)</tt>
* <tt>build_<em>association</em>(attributes = {})</tt>
* <tt>create_<em>association</em>(attributes = {})</tt>

Em todos estes métodos, <tt><em>association</em></tt> é substituído pelo símbolo passado como o primeiro argumento do método +has_one+ . Por exemplo,  na declaração abaixo:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account
end
</ruby>

Cada instância do model +Supplier+ irá conter os seguintes métodos:

<ruby>
account
account=
build_account
create_account
</ruby>

h6. <tt><em>association</em>(force_reload = false)</tt>

O método <tt><em>association</em></tt> retorna o objeto associado, se houver algum. Se nenhum objeto associado for encontrado, retornará +nil+.

<ruby>
@account = @supplier.account
</ruby>

Se o objeto associado já tiver sido buscado do banco de dados para este objeto (@supplier), a versão cacheada será retornada. Para sobrescrever este comportamento ( e forçar a leitura no banco de dados), passe +true+ para o argumento +force_reload+ . 

h6. <tt><em>association</em>=(associate)</tt>

O método <tt><em>association</em></tt>= atribui um objeto associado a este objeto. Por trás dos panos, isto significa extrair a chave primária do objeto e definir a chave estrangeira do objeto associado ao mesmo valor.

<ruby>
@suppler.account = @account
</ruby>

h6. <tt>build_<em>association</em>(attributes = {})</tt>

O método <tt>build_<em>association</em></tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir do atributos passados, e será associado através de sua chave estrangeira, mas o objeto associado não será gravado ainda.

<ruby>
@account = @supplier.build_account(:terms => "Net 30")
</ruby>

h6. create_<em>association</em>(attributes = {})

O método <tt>create_<em>association</em></tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir do atributos passados, e será associado através de sua chave estrangeira. Adicionalmente, o objeto associado _será_ gravado ( assumindo que ele passe por todas as validações).

<ruby>
@account = @supplier.create_account({:terms => "Net 30"})
</ruby>

h5. Opções para has_one

Em várias situações, você pode usar o comportamento padrão do +has_one+ sem nenhuma customização. Apesar da ênfase do Rails em convenção sobre customização, você pode alterar este comportamento de várias formas. Esta seção cobre as opções que você pode passar quando criar um associação +has_one+. Por exemplo, uma associação com várias opções pode parecer com isto:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing", :dependent => :nullify
end
</ruby>

A associação +has_one+ suporta essas opções:

* +:as+
* +:autosave+
* +:class_name+
* +:conditions+
* +:dependent+
* +:foreign_key+
* +:include+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:validate+

h6. +:as+

Definindo a opção +:as+ indica que esta será uma associação polimórfica. Associações polimórficas foram discutidas em detalhes "anteriormente neste guia":#associaes-polimrficas.

h6. +:autosave+

Se você definir a opção +:autosave+ para +true+, o Rails irá salvar qualquer membro carregado e destruir os membros que estiverem marcados para serem destruídos quando salvar o objeto paí.

h6. +:class_name+	

Se o nome do outro model não puder ser adivinhado a partir do nome da associação, você pode usar a opção +:class_name+ para fornecer o nome do model. Por exemplo, se fornecedor (supplier) possui uma conta (account), mas o nome do model atual que contém as contas (accounts) é Billing, você precisará definí-los assim:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing"
end
</ruby>

h6. +:conditions+

A opção +:conditions+ permite que você especifique as condições que o objeto associado deve satisfazer (a sintaxe é usada por uma cláusula SQL +WHERE+).

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account, :conditions => "confirmed = 1"
end
</ruby>

h6. +:dependent+

Se você definir a opção +:dependent+ para +:destroy+, ao apagar este objeto irá chamar o método destroy no objeto associado para apagá-lo também. Se você definir a opção +:dependent+ para +:delete+, então apagando este objeto irá excluir o objeto associado _sem_ chamar o método +destroy+. Se você definir a opção +:dependent+ to +:nullify+, ao excluir este objeto irá definir a chave estrangeira do objeto associado para +NULL+. 

h6. +:foreign_key+

Por convenção, o Rails adivinha que a coluna usada para guardar a chave estrangeira no outro model é o nome do model com o sufixo +_id+ adicionado. A opção  +:foreign_key+ permite que você defina o nome da chave estrangeira diretamente:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account, :foreign_key => "supp_id"
end
</ruby>

TIP: O Rails nunca irá criar a coluna da chave estrangeira para você. Você precisa defini-la explicitamente como parte de suas migrations.

h6. +:include+

Você pode usar a opção +:include+ para especificar uma associação de segunda ordem que deve ser pré carregada quando a associação for utilizada. Por exemplo, considere os models abaixo:

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
</ruby>

Se você freqüentemente buscar representantes (representatives) a partir de fornecedores (suppliers, ex.: +@supplier.account.representative+), então você pode tornar seu código mais eficiente incluindo representantes (representatives) na associação de fornecedores (suppliers) para contas (accounts):

<ruby>
class Supplier < ActiveRecord::Base
  has_one :account, :include => :representative
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
</ruby>

h6. +:order+

A opção +:order+ dita a ordem em que os objetos associados deverão ser retornados (em uma sintaxe usada por uma cláusula SQL +ORDER BY+). Como a associação +has_one+ vai retornar apenas um objeto, esta opção não deve ser necessária.

h6. +:primary_key+

Por convenção, o Rails adivinha que a coluna que irá armazenar a chave primária será +id+. Você pode sobrescrever isto e especificar a chave primária com a opção +:primary_key+ .

h6. +:readonly+

Se você definir a opção +:readonly+ para +true+, o objeto associado será exclusivamente para leitura quando for retornado pela associação.

h6. +:select+

A opção +:select+ permite que você altere a cláusula SQL +SELECT+ que é usada para retornar os atributos do objeto associado. Por padrão, o Rails retorna todas as colunas.

h6. +:source+

A opção +:source+  específica o nome da fonte para uma associação +has_one :through+ .

h6. +:source_type+

A opção +:source_type+ específica o tipo da fonte para uma associação +has_one :through+ em uma associação polimórfica.

h6. +:through+

A opção +:through+ específica um model para a junção para executar a query. "Associações +has_one :through+ já foram discutidas em detalhes":#a-associao-has-one-through.

h6. +:validate+

Se você definir a opção +:validate+ para +true+, os objetos associados serão validados sempre que você salvar este objeto. Por padrão, ele é +false+: objetos associados não serão validados quando este objeto for salvo.

h5. Como saber se existe um objeto associado?

Para saber se existe um objeto associado, simplesmente cheque +association.nil?+:

<ruby>
if @supplier.account.nil? 
  @msg = "No account found for this supplier" 
end 
</ruby>

h5. Quando objetos são salvos?

Quando você atribuir um objeto a uma associação +has_one+, este objeto é automaticamente salvo (para atualizar a chave estrangeira). Além disso, qualquer objeto que estiver sendo substituído também é salvo automaticamente, porque sua chave estrangeira também será alterada.

Se qualquer uma dessas gravações falhar devido a erros de validação, então a atribuição retornará +false+ e a própria atribuição é cancelada.

Se o objeto pai (o que estiver declarando a associação +has_one+) não estiver salvo (isto é, +new_record?+ retorna +true+) então os objeto filhos não serão salvos. Eles serão automaticamente salvos quando o pai for.

Se você quiser atribuir um objeto para uma associação +has_one+ sem salvar o objeto, use o método +association.build+ .

h4. Referência da associação +has_many+

A associação +has_many+ cria uma relação um-para-muitos com outro model. Em termos de banco de dados, esta associação diz que a outra classe terá a chave estrangeira que referência instâncias desta classe.

h5. Métodos adicionados

Quando você declara uma associação +has_many+, a classe declarante irá receber automaticamente 13 métodos relacionados a associação:

* <tt><em>collection</em>(force_reload = false)</tt>
* <tt><em>collection</em><<(object, ...)</tt>
* <tt><em>collection</em>.delete(object, ...)</tt>
* <tt><em>collection</em>=objects</tt>
* <tt><em>collection_singular</em>_ids</tt>
* <tt><em>collection_singular</em>_ids=ids</tt>
* <tt><em>collection</em>.clear</tt>
* <tt><em>collection</em>.empty?</tt>
* <tt><em>collection</em>.size</tt>
* <tt><em>collection</em>.find(...)</tt>
* <tt><em>collection</em>.exist?(...)</tt>
* <tt><em>collection</em>.build(attributes = {}, ...)</tt>
* <tt><em>collection</em>.create(attributes = {})</tt>

Em todos estes métodos, <tt><em>collection></em></tt> é substituído pelo símbolo passado como primeiro argumento em +has_many+, e <tt><em>collection_singular</em></tt> é substituído pela versão no singular deste símbolo. Por exemplo, veja abaixo:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders
end
</ruby>

Cada instância do model customer terá os seguintes métodos:

<ruby>
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.exist?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
</ruby>

h6. <tt><em>collection</em>(force_reload = false)</tt>

O método <tt><em>collection</em></tt> retorna um array com todos os objetos associados. Se não existir objeto associado, ele retorna um array vazio. 

<ruby>
@orders = @customer.orders
</ruby>

h6. <tt><em>collection</em><<(object, ...)</tt>

O método <tt><em>collection</em><<</tt> adiciona um ou mais objetos para a coleção, definindo suas chaves estrangeiras para a chave primária do model que o chamou.

<ruby>
@customer.orders << @order1
</ruby>

h6. <tt><em>collection</em>.delete(object, ...)</tt>

O método <tt><em>collection</em></tt>.delete remove um ou mais objetos da coleção definindo suas chaves estrangeiras para +NULL+.

<ruby>
@customer.orders.delete(@order1)
</ruby>

WARNING: Os objetos associados serão destruídos, se existir +:dependent => :destroy+, e excluídos se estiverem associados com +:dependent => :delete_all+.

h6. <tt><em>collection</em>=objects</tt>

O método <tt><em>collection</em>=</tt> faz com que a coleção contenha apenas os objetos passados, adicionando ou removendo apropriadamente.

h6. <tt><em>collection_singular</em>_ids</tt>

O método <tt><em>collection_singular</em>_ids</tt> retorna um array com os ids dos objetos da coleção.

<ruby>
@order_ids = @customer.order_ids
</ruby>

h6. <tt><em>collection_singular</em>_ids=ids</tt>

O método <tt><em>collection_singular</em>_ids=</tt> faz com que a coleção contenha apenas os objetos identificados pelas chaves primárias passadas, adicionando e apagando apropriadamente.

h6. <tt><em>collection</em>.clear</tt>

O método <tt><em>collection</em>.clear</tt> remove todos os objetos da coleção. Isto destrói os objetos associados se estiverem associados com a opção +:dependent => :destroy+, ou apagando-os direto do banco de dados caso seja definido +:dependent => :delete_all+, e em outros casos suas chaves estrangeiras serão definidas para +NULL+.

h6. <tt><em>collection</em>.empty?</tt>

O método <tt><em>collection</em>.empty?</tt> retorna +true+ se a coleção não contiver nenhum objeto associado.

<ruby>
<% if @customer.orders.empty? %>
  No Orders Found
<% end %>
</ruby>

h6. <tt><em>collection</em>.size</tt>


O método <tt><em>collection</em>.size</tt> retorna o número de objetos na coleção.

<ruby>
@order_count = @customer.orders.size
</ruby>

h6. <tt><em>collection</em>.find(...)</tt>

O método <tt><em>collection</em>.find</tt> encontra objetos na coleção. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.find+.

<ruby>
@open_orders = @customer.orders.find(:all, :conditions => "open = 1")
</ruby>

h6. <tt><em>collection</em>.exist?(...)</tt>

O método <tt><em>collection</em>.exist?</tt> verifica se existe o objeto associado que corresponda a condição passada como argumento. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.exists?+.

h6. <tt><em>collection</em>.build(attributes = {}, ...)</tt>

O método <tt><em>collection</em>.build</tt> retorna um ou mais novos objetos do tipo associado. Estes objetos são instanciados a partir dos atributos passados, e associados através da chave estrangeira que será criada, mas os objetos associados ainda _não_ serão salvos.

<ruby>
@order = @customer.orders.build({:order_date => Time.now, :order_number => "A12345"})
</ruby>

h6. <tt><em>collection</em>.create(attributes = {})</tt>

O método <tt><em>collection</em>.create</tt> retorna um novo objeto do tipo associado. Estes objetos são instanciados a partir dos atributos passados, e associados através da chave estrangeira que será criada, e os objetos associados  _serão_ salvos (assumindo que passem nas validações).

<ruby>
@order = @customer.orders.create({:order_date => Time.now, :order_number => "A12345"})
</ruby>

h5. Options for +has_many+

Em várias situações, você pode usar as opções padrão para o +has_many+ sem nenhuma customização. Mas você pode alterar este comportamento de várias maneiras. Esta seção cobre as opções que você pode passar quando cria uma associação +has_many+ . Por exemplo, uma associação com várias opções pode se parecer como isto:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :delete_all, :validate => :false
end
</ruby>

A associação +has_many+ suporta estas opções:

* +:as+
* +:autosave+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:dependent+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:limit+
* +:offset+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:uniq+
* +:validate+

h6. +:as+

Definindo a opção +:as+ indica que essa será uma associação polimórfica. Associações polimórficas foram discutidas em detalhes "anteriormente neste guia":#associaes-polimrficas.

h6. +:autosave+

Se você definir a opção +:autosave+ para +true+, o Rails irá salvar qualquer membro carregado e destruir os membros que estiverem marcados para serem destruídos quando salvar o objeto paí.

h6. +:class_name+

Se o nome do outro model não puder ser descoberto pelo nome da associação, você pode usar +:class_name+ para provêr o nome do model. Por exemplo, se um cliente (customer) possui muitos pedidos (orders), mas o nome atual do model que contém pedidos é +Transaction+, você pode definir as coisas desta forma:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :class_name => "Transaction"
end
</ruby>

h6. +:conditions+

A opção +:conditions+ permite que se especifique as condições que a associação precisa atender (na sintaxe usada por uma cláusula SQL +WHERE+).

<ruby>
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => "confirmed = 1"
end
</ruby>

Você também pode passar condições como um hash:

<ruby>
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => { :confirmed => true }
end
</ruby>

Se você usar +:conditions+ no estilo hash, então a criação do registro através desta associação terá automaticamente o escopo usando o hash. Neste caso, usando  +@customer.confirmed_orders.create+ ou +@customer.confirmed_orders.build+ vai criar pedidos que tenham a coluna confirmed igual a +true+.

h6. +:counter_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para contar os membros de uma associação. Com a opção +:counter_sql+, você pode especificar o comando SQL para fazer o "count" da sua forma.

NOTE: Se você especificar +:finder_sql+ mas não definir +:counter_sql+, então o SQL para contador será gerado substituindo +SELECT COUNT(*) FROM+ para a cláusula +SELECT ... FROM+ da sua declaração do +:finder_sql+.

h6. +:dependent+

Se você definir a opção +:dependent+ para +:destroy+, apagando este objeto irá chamar o método destroy de cada objeto associado para apagá-lo. Se você definir +:dependent+ para +:delete_all+, então apagar este objeto irá excluir os objetos associados _sem_ chamar o método +destroy+

NOTE: Esta opção é ignorada quando você utiliza a opção +:through+ na associação.

h6. +:extend+

A opção +:extend+ especifica o nome de um módulo para extender o proxy de associação. Extensão de associações "serão discutidas com mais detalhes neste guia":#extenses-de-associao.

h6. +:finder_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para buscar os membros da associação. Com a opção +:finder_sql+, você pode especificar a cláusula SQL para buscá-los. Se a busca dos membros associados necessitar de um SQL complexo envolvendo várias tabelas, esta opção pode ser útil.

h6. +:foreign_key+

Por convenção, o Rails descobre que a coluna usada para armazenar a chave estrangeira em outro model é o nome deste model com o sufixo +_id+ adicionado. A opção +:foreign_key+ permite que você defina o nome da chave estrangeira diretamente.

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :foreign_key => "cust_id"
end
</ruby>

TIP: O Rails nunca vai gerar as colunas para a chave estrangeira automaticamente para você. Você precisa definí-las explicitamente em suas migrations.

h6. +:group+

A opção +:group+ passa o nome de um atributo que será usado para agrupar o resultado, usando uma cláusula +GROUP BY+ no SQL.

<ruby>
class Customer < ActiveRecord::Base
  has_many :line_items, :through => :orders, :group => "orders.id"
end
</ruby>

h6. +:include+

Você pode usar a opção +:include+ para especificar associações de segunda ordem que devem ser pré-carregadas quando a associação for usada. Por exemplo, considere os models abaixo:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
</ruby>

Se você freqüentemente retorna line items diretamente de customers (+@customer.orders.line_items+), então você pode tornar seu código um pouco mais eficiente incluindo line item na associação de customers para orders:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :include => :line_items
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
</ruby>

h6. +:limit+

A opção +:limit+ permite se restringir o total de objetos que serão buscados através da associação.

<ruby>
class Customer < ActiveRecord::Base
  has_many :recent_orders, :class_name => "Order", :order => "order_date DESC", :limit => 100
end
</ruby>

h6. +:offset+

A opção +:offset+ permite que você especifique de onde a busca dos objetos associados deve iniciar. Por exemplo, se você definir +:offset => 11+, irá ignorar os 11 primeiros registros.

h6. +:order+

A opção +:order+ dita a ordem que cada objeto associado deve ser retornado ( gerando uma cláusula SQL +ORDER BY+).

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :order => "date_confirmed DESC"
end
</ruby>

h6. +:primary_key+

Por convenção, o Rails descobre que a coluna que armazenará a chave primária desta associação é +id+. Você pode sobrescrever isso e especificar a chave primária com a opção +:primary_key+.

h6. +:readonly+

Se você definir a opção +:readonly+ para +true+, os objetos associados serão somente leitura (read-only) quando forem retornados através da associação.

h6. +:select+

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que será usada para retornar os objetos associados. Por padrão, o Rails retorna todas as colunas.

WARNING: Se você especificar seu próprio +:select+, não se esqueça de incluir a chave primária e chave estrangeira do model associado. Se você não o fizer, o Rails irá disparar um erro.

h6. +:source+

A opção +:source+ especifica o nome de origem da associação para uma associação +has_many :through+. Você só precisa usar esta opção se o nome da associação não puder se inferida automaticamente a partir do nome da associação. 

h6. +:source_type+

A opção +:source_type+ especifica o tipo da associação de origem para uma associação +has_many :through+ que ocorra através de uma associação polimórfica.

h6. +:through+

A opção +:through+ especifica um model para uma junção. Associações +has_many :through+ criam uma forma de implementar uma associação many-to-many (muitos para muitos), "como discutido anteriormente neste guia":#a-associao-has-many-through .

h6. +:uniq+

A opção +:uniq => true+ remove os registros duplicados de uma coleção retornada. É mais útil em conjunto com a opção +:through+.

h6. +:validate+

Se você definir a opção +:validate+ para +false+, então os objetos associados não serão validados quando você salvar este objeto. Por padrão, este valor é +true+: objetos associados serão validados quando o objeto for salvo.

h5. Quando os objetos são salvos?

Quando você atribui um objeto a uma associação +has_many+, este objeto é automaticamente salvo (para atualizar sua chave estrangeira). Se você atribuir múltiplos objetos em uma única declaração, então todos são salvos.

Se alguma dessas gravações falhar por erros de validação, então a declaração de atribuição retornará +false+ e a atribuição será cancelada.

Se o objeto pai (o que estiver declarando a associação +has_many+) não estiver salvo (ou seja, +new_record?+ retorna +true+) então os objetos filhos não são salvos quando são adicionados. Todos os membros não salvos de uma associação serão automaticamente salvos quando o pai for salvo.

Se você quiser atribuir um objeto a uma associação +has_many+ sem salvar o objeto, use o método +<tt><em>collection</em></tt>.build+.

h4. Referência da associação +has_and_belongs_to_many+

A associação +has_and_belongs_to_many+ cria um relacionamento muitos-para-muitos com outro model. Em termos de banco de dados, ela associa duas classes através de uma tabela intermediária que inclui as chaves estrangeiras de cada classe.

h5. Métodos adicionados

Quando você declara uma associação +has_and_belongs_to_many+, a classe declarante ganha 13 métodos relacionados a associação:

* <tt><em>collection</em>(force_reload = false)</tt>
* <tt><em>collection</em><<(object, ...)</tt>
* <tt><em>collection</em>.delete(object, ...)</tt>
* <tt><em>collection</em>=objects</tt>
* <tt><em>collection_singular</em>_ids</tt>
* <tt><em>collection_singular</em>_ids=ids</tt>
* <tt><em>collection</em>.clear</tt>
* <tt><em>collection</em>.empty?</tt>
* <tt><em>collection</em>.size</tt>
* <tt><em>collection</em>.find(...)</tt>
* <tt><em>collection</em>.exist?(...)</tt>
* <tt><em>collection</em>.build(attributes = {})</tt>
* <tt><em>collection</em>.create(attributes = {})</tt>

Em todos estes métodos, <tt><em>collection</em></tt> é substituído pelo símbolo passado como primeiro argumento do +has_and_belongs_to_many+, e <tt><em>collection_singular</em></tt> é substituído pela versão no singular do símbolo. Por exemplo, a declaração abaixo:

<ruby>
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
</ruby>

Cada instância do model terá os seguintes métodos:

<ruby>
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.exist?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
</ruby>
 
h6. Métodos para colunas adicionais

Se a tabela de junção de uma associação +has_and_belongs_to_many+ possui colunas adicionais além das duas chaves estrangeiras, estas colunas serão adicionadas como atributos nos registros retornados pela associação. Registros retornados com atributos adicionais serão sempre somente leitura, porque o Rails não pode salvar alterações nestes atributos.

WARNING: O uso de atributos extra em uma tabela de junção em uma associação +has_and_belongs_to_many+ foi depreciado. Se você precisa deste tipo de comportamento complexo em uma tabela que une dois models em uma relação muitos para muitos, você deve usar uma associação +has_many :through+ ao invés de +has_and_belongs_to_many+.

h6. <tt><em>collection</em>(force_reload = false)</tt>

O método <tt><em>collection</em></tt> retorna um array com todos os objetos associados. Se não existir objetos associados, retorna um array vazio.

<ruby>
@assemblies = @part.assemblies
</ruby>

h6. <tt><em>collection</em><<(object, ...)</tt>

O método <tt><em>collection</em><<</tt> adiciona um ou mais objetos a uma coleção criando registros na tabela de junção.

<ruby>
@part.assemblies << @assembly1
</ruby>

NOTE: Este método possui os alias <tt><em>collection</em>.concat</tt> e <tt><em>collection</em>.push</tt>.

h6. <tt><em>collection</em>.delete(object, ...)</tt>

O método <tt><em>collection</em>.delete</tt> remove um ou mais objetos da coleção apagando registros da tabela de junção. Ele não destrói os objetos.

<ruby>
@part.assemblies.delete(@assembly1)
</ruby>

h6. <tt><em>collection</em>=objects</tt>

O método <tt><em>collection</em>=</tt> faz com que a coleção contenha apenas os objetos passados, adicionando e excluindo apropriadamente. 

h6. <tt><em>collection_singular</em>_ids</tt>

O método +_collection\_singular_\_ids+ retorna um array com os ids dos objetos na coleção.

<ruby>
@assembly_ids = @part.assembly_ids
</ruby>

h6. <tt><em>collection_singular</em>_ids=ids</tt>

O método <tt><em>collection_singular</em>_ids=</tt> faz com que a coleção contenha apenas os objetos identificados pelas chaves primárias passadas, inserindo e excluindo apropriadamente.

h6. <tt><em>collection</em>.clear</tt>

O método <tt><em>collection</em>.clear</tt> remove cada objeto da coleção através da exclusão das linhas na tabela de junção. Isso não destrói os objetos associados.

h6. <tt><em>collection</em>.empty?</tt>

O método <tt><em>collection</em>.empty?</tt> retorna +true+ se a coleção não contém nenhum objeto associado.

<ruby>
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
</ruby>

h6. <tt><em>collection</em>.size</tt>

A método <tt><em>collection</em>.size</tt> retorna o número de objetos na coleção.

<ruby>
@assembly_count = @part.assemblies.size
</ruby>

h6. <tt><em>collection</em>.find(...)</tt>

O método <tt><em>collection</em>.find</tt> encontra objetos dentro da coleção. Ele utiliza a mesma sintaxe e opções do +ActiveRecord::Base.find+. Acrescenta também a condição adicional de que o objeto deve estar na coleção.

<ruby>
@new_assemblies = @part.assemblies.find(:all, :conditions => ["created_at > ?", 2.days.ago])
</ruby>

h6. <tt><em>collection</em>.exist?(...)</tt>

O método <tt><em>collection</em>.exist?</tt> checa se algum objeto atende as condições na coleção. Utiliza a mesma sintaxe e opções do +ActiveRecord::Base.exists?+.

h6. <tt><em>collection</em>.build(attributes = {})</tt>

O método <tt><em>collection</em>.build</tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e uma associação será criada através da tabela de junção, mas o objeto associado _não_ será salvo.

<ruby>
@assembly = @part.assemblies.build({:assembly_name => "Transmission housing"})
</ruby>

h6. <tt><em>collection</em>.create(attributes = {})</tt>

O método <tt><em>collection</em>.create</tt> retorna um novo objeto do tipo associado. Este objeto será instanciado a partir dos atributos passados, e uma associação será criada através da tabela de junção, e o objeto associado _será_ salvo (contando que passe por todas as validações).

<ruby>
@assembly = @part.assemblies.create({:assembly_name => "Transmission housing"})
</ruby>

h5. Opções para has_and_belongs_to_many

Em muitas situações, você pode usar o comportamento padrão para +has_and_belongs_to_many+ sem nenhuma customização. Mas você pode alterar este comportamento de várias formas. Esta seção cobre as opções que você pode passar ao criar uma associação +has_and_belongs_to_many+. Por exemplo, uma associação com várias opções pode se parecer com isso:

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :uniq => true, :read_only => true
end
</ruby>

Associação +has_and_belongs_to_many+ suporta essas opções:

* +:association_foreign_key+
* +:autosave+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:delete_sql+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:insert_sql+
* +:join_table+
* +:limit+
* +:offset+
* +:order+
* +:readonly+
* +:select+
* +:uniq+
* +:validate+

h6. +:association_foreign_key+

Por convenção, o Rails adivinha que a coluna na tabela de junção usada para armazenar as chaves estrangeiras apontando para outros models é o nome do model com o sufixo +_id+ . A opção +:association_foreign_key+ permite que você defina o nome da chave estrangeira diretamente:

TIP: As opções +:foreign_key+ e +:association_foreign_key+ são úteis quando você estiver definindo uma relação muitos-para-muitos em uma auto-associação. Por exemplo:

<ruby>
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
</ruby>

h6. +:autosave+

Se você definir a opção +:autosave+ para +true+, o Rails irá salvar qualquer membro carregado e destruir os membros que estiverem marcados para serem destruídos quando salvar o objeto paí.

h6. +:class_name+

Se o nome do outro model não puder ser derivado a partir do nome da associação, você pode usar a opção +:class_name+ para passar o nome do model. Por exemplo, se parts contém assemblies, mas o nome do model que contém os assemblies é +Gadget+, você deve fazer algo como abaixo:

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :class_name => "Gadget"
end
</ruby>

h6. +:conditions+

A opção +:conditions+ permite especificar a condição que o objeto associado deve atender (na sintaxe usada por uma cláusula SQL +WHERE+).

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => "factory = 'Seattle'"
end
</ruby>

Você também pode definir condições através de um hash:

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => { :factory => 'Seattle' }
end
</ruby>

Se você utilizar +:conditions+ no estilo hash, então a criação dos registros pela associação será automaticamente escopada usando o hash. Neste casa, usando +@parts.assemblies.create+ ou +@parts.assemblies.build+ irá criar registros onde a coluna de criação conterá o valor "Seattle".

h6. +:counter_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para contar os membros da associação. Com a opção +:counter_sql+, você pode especificar o SQL para fazer a contagem.

NOTE: Se você especificar +:finder_sql+ mas não +:counter_sql+, o SQL contador será gerado substituindo +SELECT COUNT(*) FROM+ para a cláusula +SELECT ... FROM+ para a declaração do seu +:finder_sql+.

h6. +:delete_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para remover as ligações entre as classes associadas. Com a opção +:delete_sql+, você pode especificar uma cláusula SQL para exclusão.

h6. +:extend+

A opção +:extend+ especifica um módulo para estender o proxy de associação. Extensão de associações "serão discutidas com mais detalhes neste guia":#extenses-de-associao.

h6. +:finder_sql+

Normalmente Rails gera automaticamente o SQL apropriado para buscar os membros da associação. Com a opção +:finder_sql+, você pode especificar sua própria cláusula SQL para buscar os registros. Se a busca dos objetos requer um SQL complexo em um hierarquia de múltiplas tabelas, então esta opção pode ser necessária.

h6. +:foreign_key+

Por convenção, o Rails adivinha que a coluna na tabela de junção que será usada para armazenar a chave estrangeira será o nome do model mais o sufixo +_id+. A opção +:foreign_key+ permite que você especifique o nome da chave estrangeira diretamente:

<ruby>
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User",
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
</ruby>

h6. +:group+

A opção +:group+ informa o nome de um atributo que será usado para agrupar os resultados, usando uma cláusula +GROUP BY+ em um SQL.

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :group => "factory"
end
</ruby>

h6. +:include+

Você pode usar a opção +:include+ para especificar uma associação de segunda ordem que deve ser pré-carregada quando a associação for utilizada.

h6. +:insert_sql+

Normalmente o Rails gera automaticamente o SQL apropriado para criar a associação entre as classes. Com a opção +:insert_sql+, você pode especificar um comando SQL para inserir os registros da sua forma.

h6. +:join_table+

Se o nome padrão da tabela de junção, baseada em ordem alfabética, não é o que você deseja, então é possível usar a opção +:join_table+ para sobrescrever este comportamento.

h6. +:limit+

A opção +:limit+ permite a você restringir o número total de objeto que serão buscados através da associação.

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "created_at DESC",
    :limit => 50
end
</ruby>

h6. +:offset+

A opção +:offset+ permite que você especifique de onde a busca dos objetos associados deve iniciar. Por exemplo, se você definir +:offset => 11+, irá ignorar os 11 primeiros registros.

h6. +:order+

A opção +:order+ dita a ordem que cada objeto associado deve ser retornado (gerando uma cláusula SQL +ORDER BY+).

<ruby>
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "assembly_name ASC"
end
</ruby>

h6. +:readonly+

Se você definir a opção +:readonly+ para +true+, os objetos associados serão somente leitura quando forem retornados através da associação.

h6. +:select+

A opção +:select+ permite que você sobrescreva a cláusula SQL +SELECT+ que será usada para retornar os objetos associados. Por padrão, o Rails retorna todas as colunas.

h6. +:uniq+

Especificar a opção +:uniq => true+ remove duplicatas da coleção.

h6. +:validate+

Quando você define a opção +:validate+ para +false, os objetos associados não serão validados quando você salvar este objeto. Por padrão, esta opção recebe +true+: objetos associados também serão validados quando o objeto for salvo.

h5. Quando os Objetos são Salvos?

Quando você atribuir um objeto a uma associação +has_and_belongs_to_many+, este objeto é automaticamente salvo (para atualizar a tabela de junção). Se você atribuir múltiplos objetos em uma declaração, então todos são salvos.

Se uma das gravações falhar durante o processo de validações, então a atribuição retornará +false+ e a atribuição em si será cancelada.

Se o objeto pai (o que estiver declarando a associação +has_and_belongs_to_many+) não estiver salvo (ou seja, +new_record?+ retorna +true+) então os filhos também não serão salvos quando forem adicionados. Todos os membros não salvos na associação serão automaticamente salvos quando o pai for salvo.

Se você quiser atribuir um objeto a uma associação +has_and_belongs_to_many+ sem salvar o objeto, use o método <tt><em>collection</em>.build</tt>.

h4. Association Callbacks

Callbacks normais são atrelados ao ciclo de vida de objetos Active Record, permitindo que você trabalhe com estes objetos em vários pontos. Por exemplo, você pode usar o callback +:before_save+ para fazer com que algo aconteça antes do objeto ser salvo.

Callbacks de associação são similares a callbacks normais, mas eles são acionados por eventos no ciclo de vida da coleção. Existem quatro callbacks de associação disponíveis:

* +before_add+
* +after_add+
* +before_remove+
* +after_remove+

Você define callbacks de associação adicionando opções na declaração da associação. Por exemplo:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end
</ruby>

O Rails passa o objeto a ser adicionado ou removido para o callback.

Você pode empilhar callbacks em um único evento passando-os como array:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end
</ruby>

Se +before_add+ disparar uma exceção, o objeto não será adicionado a coleção. Similarmente, se o callback +before_remove+ disparar uma exceção, o objeto não será removido da coleção.

h4. Extensões de associação

Você não está limitado as funcionalidades que o Rails automaticamente constrói nos objetos de um proxy de associação. Você pode extender estes objetos através de módulos anônimos, adicionando novos finders, creators ou outros métodos. Por exemplo:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by_region_id(order_number[0..2])
    end
  end
end
</ruby>

Se você tiver uma extensão que deve ser compartilhada por várias associações, então você pode usar um módulo nomeado. Por exemplo:

<ruby>
module FindRecentExtension
  def find_recent
    find(:all, :conditions => ["created_at > ?", 5.days.ago])
  end
end

class Customer < ActiveRecord::Base
  has_many :orders, :extend => FindRecentExtension
end

class Supplier < ActiveRecord::Base
  has_many :deliveries, :extend => FindRecentExtension
end
</ruby>

Para incluir mais de um módulo de extensão em uma única associação, basta especificar um array de modulos:

<ruby>
class Customer < ActiveRecord::Base
  has_many :orders, :extend => [FindRecentExtension, FindActiveExtension]
end
</ruby>

Extensões podem referenciar o proxy de associação através de três acessadores:

* +proxy_owner+ retorna o objeto que a associação faz parte.
* +proxy_reflection+ retorna o objeto de reflexão que descreve a associação.
* +proxy_target+ retorna o objeto associado para +belongs_to+ ou +has_one+, ou a coleção de objetos associados para +has_many+ ou +has_and_belongs_to_many+.

h3. Changelog 

"Ticket no Lighthouse":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/11

* Março 13, 2009: Revisão da tradução por "Fabio Kreusch":translators.html#fabiokr
* February  28, 2009: Atualização da tradução com a opção +:autosave+ "Daniel Lopes":translators.html#danielvlopes
* Fevereiro 1, 2009: Adicionado a opção +:autosave+ "Mike Gunderloy":credits.html#mgunderloy
* Janeiro   18, 2009: Primeira versão da tradução para português por "Daniel Lopes":translators.html#danielvlopes
* Setembro  28, 2008: Corrigido o diagrama +has_many :through+, adicionado o diagrama para associações polimórficas, por "Mike Gunderloy":credits.html#mgunderloy. First release version.
* Setembro  22, 2008: Adicionado diagramas, coisas diversas. por "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* Setembro  14, 2008: Versão inicial por "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
