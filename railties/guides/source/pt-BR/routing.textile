h2. Roteamento Rails de fora para dentro

Este guia aborda as características do roteamento em Rails. Ao completar este guia, você será capaz de:

* Entender a proposta do roteamento
* Decifrar o código em +routes.rb+
* Construir suas próprias rotas, utilizando o estilo clássico em hash ou o estilo atualmente preferido em RESTful
* Identificar como uma rota pode mapear do controlador para uma ação

endprologue.

h3. A dupla finalidade do roteamento

Roteamento Rails é um mecanismo de encaminhamento bidirecional - como se você pudesse transformar isso em um papel, e depois cada papel de volta em árvore. Especificamente, que liga as solicitações HTTP recebidas para o código no controlador da sua aplicação, e ajuda a você gerar URLs sem ter que codificar as strings.

h4. Conectando URLs com o código

Quando sua aplicação Rails recebe uma solicitação HTTP, fala

<pre>
GET /patients/17
</pre>

a engine de roteamento dentro do Rails é a parte do código que envia uma solicitação para o local apropriado na sua aplicação. Neste caso, a aplicação provavelmente executaria a ação +show+ dentro do controlador +patients+, mostrando os detalhes do paciente cujo ID é 17.

h4. Gerando URLs do código

O roteamento também funciona no caminho reverso. Se sua aplicação contem este código:

<ruby>
@patient = Patient.find(17)
</ruby>
<ruby>
<%= link_to "Patient Record", patient_path(@patient) %>
</ruby>

Então a engine de roteamento é a parte que traduz o link para a URL como +http://example.com/patients/17+. Usando o roteamento nesta forma, você pode reduzir a fragilidade da sua aplicação se comparada com uma aplicação com URLs codificada dificilmente, e torna o seu código ser facilmente lido e entendido.

NOTE: Patient necessita ser declarado como um recurso para a tradução de rotas nomeadas possam ser disponível.

h3. Rápido Tour de Routes.rb

Há dois componentes para roteamento no Rails: a própria engine de roteameneto, que é fornecida como parte do Rails, e o arquivo +config/routes.rb+, que contém as rotas atuais que serão usadas pela sua aplicação. Aprender exatamente o que você pode colocar em +routes.rb+ é o tópico principal deste guia, mas antes vamos obter uma visão geral rápida.

h4. Processando o arquivo

No formato, +routes.rb+ não é nada mais do que um grande bloco enviado para +ActionController::Routing::Routes.draw+. Junto com este bloco, você pode ter comentários, mas é provável que a maior parte do seu contéudo será de linhas individuais de código - cada linha iniciando uma rota na sua aplicação. Você encontrará cinco tipos principais de conteúdo neste arquivo:

* Rotas RESTful
* Rotas Nomeadas
* Rotas Aninhadas
* Rotas Regulares
* Rotas Padrão

Cada um desses tipos de rotas são cobertas em mais detalhes neste guia.

O arquivo +routes.rb+ é processado de cima para baixo quando chega uma requisição. A requisição será executada na primeira combinação de rota. Se nenhuma rota combina, então o Rails retorna um status HTTP 404 ao chamador.

h4. Rotas RESTful

Rotas RESTful tiram a vantagem da orientação built-in do REST do Rails para empacotar muitas das informações de roteamento em uma simples declaração. Uma rota RESTful se parece como esta:

<ruby>
map.resources :books
</ruby>

h4. Rotas nomeadas

Rotas nomeadas da a você links legivéis no seu código, bem como manipulação nas solicitações recebidas. Veja aqui uma típica rota nomeada:

<ruby>
map.login '/login', :controller => 'sessions', :action => 'new'
</ruby>

h4. Rotas aninhadas

Rotas aninhadas permite você declarar que um recurso está contido dentro de outro recurso. Você verá mais tarde como pode traduzir para URLs e caminhos no seu código. Por exemplo, se sua aplicação incluir parts, cada uma das quais pertence a um assembly, você pode declarar esta rota aninhada como:

<ruby>
map.resources :assemblies do |assemblies|
  assemblies.resources :parts
end
</ruby>

h4. Rotas regulares

Em muitas aplicações, você verá roteamentos não RESTful, que conecta explicitamente cada parte da URL a uma ação em particular. Por exemplo,

<ruby>
map.connect 'parts/:number', :controller => 'inventory', :action => 'show'
</ruby>

h4. Rotas padrão

As rotas padrão são a forma segura de capturar requisições sem outras formas de rotas. Muitas aplicações Rails contém este par de rotas como padrão:

<ruby>
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
</ruby>

Estas rotas padrão são geradas automaticamentes quando você cria uma nova aplicação Rails. Se você está usando roteamento RESTful para tudo na sua aplicação, você provavelmente precisará removê-la. Mas verifique se você não está usando rotas padrões antes de removê-las.

h3. Roteamento RESTful: o Padrão Rails

Roteamento RESTful é o padrão corrente de roteamento no Rails, e a única que você deve escolher para novas aplicações. Pode demorar um pouco enquanto você entende como funciona o roteamento RESTful, mas que vale o esforço; seu código será mais fácil de ser lido e você estará trabalho com Rails, ao invés de lutar contra ele, quando você usa este estilo de roteamento.

h4. O que é REST?

O Fundação do roteamento RESTful é geralmente considerado na tese de doutorado de Roy Fielding, "Architectural Styles and the Design of Network-based Software Architectures":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm. Felizmente, você não precisa ler este documento para entender como o REST funciona no Rails. REST é um acrônimo para Representational State Transfer, que resume-se em dois principios fundamentais para nossos propósitos:

* Usando identificadores de recurso (na qual, para o propósito da discussão, você pode pensar como as URLs) para representar recursos
* Transferindo representações de status entre recursos e componentes do sistema.

Por exemplo, para uma requisição em uma aplicação Rails como esta:

<pre>
DELETE /photos/17
</pre>

seria entendido como uma referencia a um recurso photo com o ID 17, e indicaria a ação desejada - deletar este recurso. REST é um estilo natural para a arquitetura de aplicações web, e Rails faz isso de uma forma mais natural usando convenções para protejer você de algumas complexidades do RESTful.

h4. CRUD, verbos e ações  

No Rails, uma rota RESTful fornece o mapeamento entre verbos HTTP, ações de controladores, e (implicitamente) a operações CRUD no banco de dados. Uma entrada única no arquivo de roteamento, como essa

<ruby>
map.resources :photos
</ruby>

cria sete diferentes rotas na sua aplicação:

|_.HTTP verb  |_.URL             |_.controller  |_.action   |_.used for|
|GET        |/photos         |Photos      |index    |mostra a lista de todas as fotos|
|GET        |/photos/new     |Photos      |new      |retorna um formulário HTML para a criação de uma nova foto|
|POST       |/photos         |Photos      |create   |cria uma nova foto|
|GET        |/photos/1       |Photos      |show     |mostra uma foto específica|
|GET        |/photos/1/edit  |Photos      |edit     |retorna um formulário HTML para edição da foto|
|PUT        |/photos/1       |Photos      |update   |atualiza uma foto específica|
|DELETE     |/photos/1       |Photos      |destroy  |apaga uma foto específica|

Para estas rotas específicas (aqueles que fazem referencia a um uníco recurso), o indetificador do recurso deverá ser disponível na ação correspondente de um controlador como um +params[:id]+.

TIP: Se você consistentimente usar rotas RESTful na sua aplicação, você deverá desabilitar as rotas padrões em +routes.rb+ de modo que o Rails aplicará o mapeamento entre verbos HTTP e rotas.

h4. URLs e Caminhos

Criando uma rota RESTful também tornará disponível um monte de helpers dentro da sua aplicação:

* +photos_url+ e +photos_path+ mapeia do caminho para as ações index e create.
* +new_photo_url+ e +new_photo_path+ mapeia o caminho para a ação new
* +edit_photo_url+ e +edit_photo_path+ mapeia o caminho para a ação edit
* +photo_url+ e +photo_path+ mapeia o caminho para as ações show, update e destroy

NOTE: Por que o roteamento faz uso de verbos HTTP, bem como o caminho no pedido para expedir requisições, as setes rotas geradas pelo roteamento RESTful só dão origem a quatro pares de helpers.

Em cada caso, o helper +_url+ gera uma string contendo toda a URL que a aplicação irá entender, enquanto o helper +_path+ gera uma string contendo um caminho relativo para a raiz da aplicação. Por exemplo:

<ruby>
photos_url  # => "http://www.example.com/photos"
photos_path # => "/photos"
</ruby>

h4. Definindo Múltiplos Recursos ao Mesmo Tempo

Se você precisa criar rotas para mais de um recurso RESTful, você pode diminuir um pouco de digitar, definindo todas as chamadas para +map.resources+:

<ruby>
map.resources :photos, :books, :videos
</ruby>

Isto tem exatamente o mesmo efeito de

<ruby>
map.resources :photos
map.resources :books
map.resources :videos
</ruby>

h4. Recursos singulares

Você pode também aplicar o roteamento RESTful para um único recurso dentro da sua aplicação. Neste caso, você usa +map.resource+ em vez de +map.resources+ e a geração das rotas é ligeiramente diferente. Por exemplo, uma entrada para o roteamento

<ruby>
map.resource :geocoder
</ruby>

cria seis rotas diferentes na sua aplicação:

|_.HTTP verb  |_.URL             |_.controller  |_.action   |_.used for|
|GET        |/geocoder/new   |Geocoders   |new      |retorna um formulário HTML para criação de um novo geocoder|
|POST       |/geocoder       |Geocoders   |create   |cria um novo geocoder|
|GET        |/geocoder       |Geocoders   |show     |mostra um e somente um recurso geocoder|
|GET        |/geocoder/edit  |Geocoders   |edit     |retorna um formulário HTML para edição do geocoder|
|PUT        |/geocoder       |Geocoders   |update   |atualiza um e somente um recurso do geocoder|
|DELETE     |/geocoder       |Geocoders   |destroy  |apaga um recurso geocoder|

NOTE: Mesmo que o nome do recurso seja singular em +routes.rb+, o controlador correspondente continua no plural.

Uma rota RESTful singular gera um conjunto abreviados de helpers:

* +new_geocoder_url+ e +new_geocoder_path+ mapeia o caminho para a ação new
* +edit_geocoder_url+ e +edit_geocoder_path+ mapeia o caminho para a ação edit
* +geocoder_url+ e +geocoder_path+ mapeia o caminho para as ações create, show, update e destroy.

h4. Customizando recursos

Apesar das convenções do roteamento RESTful serem suficientes para muitas aplicações, existe inúmeras formas de customizar a forma como uma rota RESTful funciona. Estas opções incluem:

* +:controller+
* +:singular+
* +:requirements+
* +:conditions+
* +:as+
* +:path_names+
* +:path_prefix+
* +:name_prefix+

Você pode adicionar rotas adicionais pelas opções +:member+ e +:collection+, na qual serão discutidos mais tarde neste guia.

h5. Usando :controller

A opção +:controller+ permite você usar o nome do controlador diferente do nome do recurso público. Por exemplo, esta entrada no roteamento:

<ruby>
map.resources :photos, :controller => "images"
</ruby>

reconhecerá o recebimento de URLs contendo +photo+ mas a requisição das rotas para o controlador Images :

|_.HTTP verb  |_.URL             |_.controller  |_.action   |_.used for|
|GET        |/photos         |Images      |index    |mostra a lista de todas as imagens|
|GET        |/photos/new     |Images      |new      |retorna um formulário HTML para criação de uma nova imagem|
|POST       |/photos         |Images      |create   |cria uma nova imagem|
|GET        |/photos/1       |Images      |show     |mostra uma imagem específica|
|GET        |/photos/1/edit  |Images      |edit     |retorna um formulário HTML para edição da imagem|
|PUT        |/photos/1       |Images      |update   |atualiza uma imagem específica|
|DELETE     |/photos/1       Images       |destroy  |apaga uma imagem específica|

NOTE: Os helpers será gerado com o nome do recurso, não com o nome do controlador. Portanto neste caso você receberá +photos_path+, +new_photo_path+, e assim por diante.

h4. 'Namespaces' de Controladores e Roteamento

Rails permite que você agrupe seus controladores dentro de 'namespaces' salvando dentro de pastas debaixo de +app/controllers+. A opção +:controllers+ fornece uma forma conveniente para usar essas rotas. Por exemplo, você pode ter um recurso cujo controlador é apenas para adminitração de usuários na pasta +admin+:

<ruby>
map.resources :adminphotos, :controller => "admin/photos"
</ruby>

Se você usa o namespaces do controlador, você precisa ter cuidado com a sutileza no código de roteamento do Rails: ele tenta preservar o máximo do namespace de uma requisição anterior o quanto possível. Por exemplo, se você estiver em uma visão gerada pelo helper +adminphoto_path+, e seguida de um link gerado com +<%= link_to "show", adminphoto(1) %>+ você acabará com a visão gerada por +admin/photos/show+ mas você vai acabar no mesmo lugar se você tiver +<%= link_to "show", {:controller => "photos", :action => "show"} %>+ por quê o Rails mostrará a URL relativa a URL atual.

TIP: Se você quiser garantir que o link vá para um controlador de nível superior, use uma barra precedendo a âncora para o nome do controlador: +<%= link_to "show", {:controller => "/photos", :action => "show"} %>+

Você pode especifícar o namespace do controlador com a opção +:namespace+ ao invés do caminho:

<ruby>
map.resources :adminphotos, :namespace => "admin", :controller => "photos"
</ruby>

Isso pode ser especialmente útil quando combinada com +with_options+ para mapear múltiplas rotas com namespace:

<ruby>
map.with_options(:namespace => "admin") do |admin|
  admin.resources :photos, :videos
end
</ruby>

Isso iria lhe dar o roteamento para os controladores +admin/photos+ e +admin/videos+.

h5. Usando :singular

Se por alguma razão o Rails não está fazendo o que você deseja, convertendo o nome do recurso do plural para um único nome no membro das rotas, você pode substituir seu julgamento com a opção +:singular+:

<ruby>
map.resources :teeth, :singular => "tooth"
</ruby>

TIP: Dependendo de outros códigos na sua aplicação, você pode optar em adicionar regras adicionais para a classe +Inflector+.

h5. Usando :requirements

Você pode usar a opção +:requirements+ em uma rota RESTful para impor um formato implícto sobre o parâmetro +:id+ em rotas singulares. Por exemplo:

<ruby>
map.resources :photos, :requirements => {:id => /[A-Z][A-Z][0-9]+/}
</ruby>

Esta declaração obriga o paramêtro a casar com a expressão regular fornecida. Então, neste caso, +/photos/1+ não ia ser reconhecida por esta rota, mas +/photos/RR27+ ia.

h5. Usando :conditions

Condições no roteamento Rails são usadas atualmente para ajutar o verbo HTTP para rotas individuais. Apesar de na teoria você poder ajustar isto para as rotas RESTful, na prática não são é uma boa razão para fazê-lo. (Você aprenderá mais sobre condições na discussão de roteamento clássico depois neste guia)

h5. Usando :as

A opção +:as+ permite que você sobrescreva o nomeamento normal para os paths gerados atualmente. Por exemplo:

<ruby>
map.resources :photos, :as => "images"
</ruby>

reconhecerá URLS recebidas contendo +image+ mas a rota requisita o controlador Photos:

|_.HTTP verb  |_.URL             |_.controller  |_.action   |_.used for|
|GET        |/images         |Photos      |index    |mostra a lista de todas as fotoso|
|GET        |/images/new     |Photos      |new      |retorna um formulário HTML para criação de uma novo foto|
|POST       |/images         |Photos      |create   |cria uma nova foto|
|GET        |/images/1       |Photos      |show     |mostra uma foto específica|
|GET        |/images/1/edit  |Photos      |edit     |retorna um formulário HTML para edição de uma foto|
|PUT        |/images/1       |Photos      |update   |atualiza uma foto específica|
|DELETE     |/images/1       |Photos      |destroy  |apaga uma foto específica|

NOTE: Os helpers irão ser gerados com o mesmo nome do recurso, não o nome path. Então neste caso, você ainda obterá +photos_path+, +new_photo_path+, e assim por diante.

h5. Usando :path_names

A opção +:path_names+ permite que você sobrescreva os segmentos "new" e "edit" gerados automaticamentes nas URLs:

<ruby>
map.resources :photos, :path_names => { :new => 'make', :edit => 'change' }
</ruby>

Isto causaria o roteamento para URLs reconhecidas como

<pre>
/photos/make
/photos/1/change
</pre>

NOTE: Os nomes das ações atuais não serão alterados por esta opção; as duas URLs que mostram as rotas para as ações new e edit continuam funcionando.

TIP: Se você está querendo mudar esta opção de modo uniforme para todas as suas rotas, você pode definir um padrão em seu environment:

<ruby>
config.action_controller.resources_path_names = { :new => 'make', :edit => 'change' }
</ruby>

h5. Usando :path_prefix

A opção +:path_prefix+ permite que você adicione paramêtros adicionais que serão prefixadas para as rotas reconhecidas. Por exemplo, suponha que cada foto na sua aplicação possua a um fotografo em particular. No caso, você deve declarar esta rota:

<ruby>
map.resources :photos, :path_prefix => '/photographers/:photographer_id'
</ruby>

Rotas reconhecidas por esta entrada incluem:

<pre>
/photographers/1/photos/2
/photographers/1/photos
</pre>

NOTE: Na maioria dos casos, é mais simples de reconhecer URLs deste tipo, criando recursos aninhados, como discutido na próxima seção

NOTE: Você também pode usar +:path_prefix+ com rotas não RESTful.

h5. Usando :name_prefix

Você pode usar a opção :name_prefix para evitar colisões entre rotas. Isto é mais usando quando você tem dois recursos com o mesmo nome que usam +:path_prefix+ para mapear diferentemente. Por exemplo:

<ruby>
map.resources :photos, :path_prefix => '/photographers/:photographer_id', :name_prefix => 'photographer_'
map.resources :photos, :path_prefix => '/agencies/:agency_id', :name_prefix => 'agency_'
</ruby>>

Com esta combinação você irá receber helpers tais como +photographer_photos_path+ e +agency_edit_photo_path+ para usar no seu código.

NOTE: Você pode usar +:name_prefix+ com rotas não RESTful.

h4. Recursos aninhados

É comum ter recursos que são logicamente filhos de outros recursos. Por exemplo, suponha que a sua aplicação inclua os seguintes modelos:

<ruby>
class Magazine < ActiveRecord::Base
  has_many :ads
end

class Ad < ActiveRecord::Base
  belongs_to :magazine
end
<pre>

Cada ad é logicamente subordinado a uma magazine. Rotas aninhadas permite que você captura o relacionamento no seu roteamento. Neste caso, você deve incluir nas suas rotas a declaração:

<ruby>
map.resources :magazines do |magazine|
  magazine.resources :ads
end 
<pre>

Além dessas rotas para magazines, esta declaração criará rotas para ads, cada um da qual exige a especificação de uma magazine na URL:

|_.verbo HTTP  |_.URL                      |_.controlador  |_.ação   |_.usado por|
|GET        |/magazines/1/ads         |Ads         |index    |mostra a lista de todas as ads para uma magazine específica|
|GET        |/magazines/1/ads/new     |Ads         |new      |retorna um formulário HTML para criação de um novo ad pertencente a um magazine especifíco|
|POST       |/magazines/1/ads         |Ads         |create   |cria um novo ad pertencente a uma magazine especifíca|
|GET        |/magazines/1/ads/1       |Ads         |show     |mostra um especifíco ad pertencente display a specific ad belonging to a specific magazine|
|GET        |/magazines/1/ads/1/edit  |Ads         |edit     |retorna um formulário HTML para edição de um ad pertencente a uma magazine especifíca|
|PUT        |/magazines/1/ads/1       |Ads         |update   |atualiza um especifíco ad pertencente a uma magazine especifíca|
|DELETE     |/magazines/1/ads/1       |Ads         |destroy  |apaga um ad especifíco pertencente a um magazine especifíco|


Além disso criará helpers de roteamento como +magazine_ads_url+ e +edit_magazine_ad_path+.

h5. Usando :name_prefix

A opção +:name_prefix+ sobrescreve um prefixo automaticamente gerado nos helpers das rotas aninhadas. Por exemplo, 

<ruby>
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix => 'periodical'
end 
</ruby>

Isso irá criar helpers de roteamento como +periodical_ads_url+ e +periodical_edit_ad_path+. Você pode mesmo utilizar +:name_prefix+ para esconder o prefixo completamente:

<ruby>
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix => nil
end 
</ruby>

Isso irá criar helpers de roteamente como +ads_url+ e +edit_ad_path+. Note que continua exigindo que você forneça um article id:

<ruby>
ads_url(@magazine)
edit_ad_path(@magazine, @ad)
</ruby>

h5. Usando :has_one e :has_many

As opções +:has_one+ e +:has_many+ fornece uma notação sucinta para simples rotas aninhadas. Use +:has_one+ para aninhar um único recurso, ou +:has_many+ para aninhar um recurso no plural:

<ruby>
map.resources :photos, :has_one => :photographer, :has_many => [:publications, :versions]
</ruby>

Isso tem o mesmo efeito que as sequintes declarações:

<ruby>
map.resources :photos do |photo|
  photo.resource :photographer
  photo.resources :publications
  photo.resources :versions
end
</ruby>
 
h5. Limites para os aninhamentos

Você pode aninhar recursos com outros recursos aninhados se você quiser. Por exemplo:

<ruby>
map.resources :publishers do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
</ruby>

Entretanto, sem a utilização de +name_prefix => nil+, os recursos extremamentes aninhados se tornarão pesado. Neste caso, por exemplo, a aplicação reconheceria URLs como

<pre>
/publishers/1/magazines/2/photos/3
</pre>

O helper correspondente a rota seria +publisher_magazine_photo_url+, exigindo que você especifíque objetos para todos os níveis da árvore. Esta situação é confusa o suficiente para que um popular "artigo":http://weblog.jamisbuck.org/2007/2/5/nesting-resources por Jamis Buck propõe uma regra de ouro para um bom design em Rails:

_Recursos nunca devem ser aninhados mais do que 1 nível de profundidade._

h5. Aninhamento Superficial

A opção +:shallow+ fornece uma solução elegante para as dificuldades de rotas extremamentes aninhadas. Se você especifícar esta opção a qualquer nível de roteamento, então os caminhos para recursos aninhados que referência a um membro especifíco (isto é, aqueles com o parâmetro +:id+) não usará o caminho ou o nome do prefíxo. Para ver o que isso significa, considere a sequinte configuração de rotas:

<ruby>
map.resources :publishers, :shallow => true do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
</ruby>

Isso permitirá o reconhecimentos (entre outros) dessas rotas:

<pre>
/publishers/1           ==> publisher_path(1)
/publishers/1/magazines ==> publisher_magazines_path(1)
/magazines/2            ==> magazine_path(2)
/magazines/2/photos     ==> magazines_photos_path(2)
/photos/3               ==> photo_path(3)
</pre>

Com o roteamento superficial, você somente precisa fornecer informações suficiente para identificar unicamente o recurso que você precisa para trabalhar com ele - mas você _pode_ fornecer mais informações. Todas as rotas aninhadas continuam funcionando, do mesmo modo sem o aninhamento superficial, mas as rotas menos profundamente aninhadas (mesmo de rotas diretas) funcionarão bem. Então, mesmo com a declaração acima, todas estas rotas se referem ao mesmo recurso:

<pre>
/publishers/1/magazines/2/photos/3   ==> publisher_magazine_photo_path(1,2,3)
/magazines/2/photos/3                ==> magazine_photo_path(2,3)
/photos/3                            ==> photo_path(3)
</pre>

O aninhamento superficial dá a flexibilidade para usar rotas curtas diretas quando você quiser, ao mesmo tempo que preserva as longas rotas aninhadas, as vezes, quando acrescentam códigos com clareza.

Se você quiser você pode combinar o aninhamento surpeficial com as opções +:has_one+ e +:has_many+:

<ruby>
map.resources :publishers, :has_many => { :magazines => :photos }, :shallow => true
</ruby>

h4. Geração de rotas a partir de Arrays

Além de utilizar a os helpers geradores de roteamento, Rails também pode gerar rotas RESTful de um array de paramêtros. Por exemplo, suponha que você tem a configuração de rotas geradas com essas entradas no routes.rb:

<ruby>
map.resources :magazines do |magazine|
  magazine.resources :ads
end
</ruby>

Rails gerará helpers como magazine_ad_path que você pode usar na construção de links:

<ruby>
<%= link_to "Ad details", magazine_ad_path(@magazine, @ad) %>
</ruby>

Outra forma para referir a mesma rota com um array de objetos:

<ruby>
<%= link_to "Ad details", [@magazine, @ad] %>
</ruby>

Este formato é especialmente útil quando você não sabe em tempo de execução os vários tipos de objetos que podem ser usados em um link particular.

h4. Recursos em Namespaces

É possível fazer algumas coisas muito complexas pela combinação de +:path_prefix+ e +:name_prefix+. Por exemplo, você pode usar a combinação dessas duas opções para mover recursos administrativos para sua própria pasta na sua aplicação:

<ruby>
map.resources :photos, :path_prefix => 'admin', :controller => 'admin/photos'
map.resources :tags, :name_prefix => 'admin_photo_', :path_prefix => 'admin/photos/:photo_id', :controller => 'admin/photo_tags'
map.resources :ratings, :name_prefix => 'admin_photo_', :path_prefix => 'admin/photos/:photo_id', :controller => 'admin/photo_ratings'
</ruby>

A boa notícia é que se você se encontrar com este nível de complexidade, você pode parar. Rails suporta _recursos namespaced_ para mover recursos de lugares para suas próprias pastas com um estalo. Aqui é uma versão namespaced da mesma árvore de rotas:

<ruby>
map.namespace(:admin) do |admin|
	admin.resources :photos,
	  :has_many => { :tags, :ratings}
end
</ruby>

Como você pode ver, a versão namespaced é muito mais sucinta do que do outro modo - mas ainda cria as mesmas rotas. Por exemplo, você vai ter +admin_photos_url+ que espera encontrar um +Admin::PhotosController+ e ainda corresponde com +admin/photos+, e +admin_photos_ratings_path+ corresponde com +/admin/photos/_photo_id_/ratings+, esperado para usar +Admin::RatingsController+. Mesmo que você não está especificando explicitamente +path_prefix+, o código de roteamento calculará o apropriado +path_prefix+ do roteamento aninhado.

h4. Adicionando mais ações RESTful

Você não está limitado as sete rotas que o roteamento RESTful cria por padrão. Se você quiser, você pode adicionar mais membros de rotas (aqueles que se aplicam para uma única instância do recurso), novas rotas adicionais (aqueles que você aplica para a criação de novos recursos), ou uma coleção de rotas adicionais (aqueles que se aplicam para a coleção de recursos como um todo).

h5. Adicionando Membros de Rotas

Para adicionar um membro de uma rota, use a opção +:member+:

<ruby>
map.resources :photos, :member => { :preview => :get }
</ruby>

Isso habilitará o Rails para reconhecer URLs como +/photos/1/preview+ usando o verbo HTTP GET, e rotea-las para a ação preview do controlador de Photos. Isto irá criar o helper de rota +preview_photo+.

Dentro da hash de membros de rotas, o nome de cada rota especifíca um verbo HTTP que irá ser reconhecido. Você pode usar +:get+, +:put+, +:post+, +:delete+, ou +:any+. Além disso você pode especificar um array de métodos, se você precisar de mais do que um, mas se você não quiser permitir qualquer um:

<ruby>
map.resources :photos, :member => { :prepare => [:get, :post] }
</ruby>

h5. Adicionando uma Coleção de Rotas

Para adicionar uma coleção de rotas, usar a opção +:collection+:

<ruby>
map.resources :photos, :collection => { :search => :get }
</ruby>

Isso habilitará o Rails a reconhecer URLs como +/photos/search+ usando o verbo HTTP GET, e a rota para a ação search no controlador de Photos. Isso criará o helper +search_photos+ para esta rota.

Assim como os membros das rotas, você pode especificar um array de métodos para uma collection da rota:

<ruby>
map.resources :photos, :collection => { :search => [:get, :post] }
</ruby>

h5. Adicionando Novas Rotas

Para adicionar novas rotas (um que cria novos recursos), use a opção +:new+:

<ruby>
map.resources :photos, :new => { :upload => :post }
</ruby>

Isto habilitará o Rails para reconheceria URLs como +/photos/upload+ usando o verbo HTTP POST, e a rota para a ação upload no controlador de Photos. Isso criará o helper +upload_photos+ para esta rota.

TIP: Se você precisa redefinir os métodos aceitáveis um por um para ações padrão, você pode fazer um mapeamento explicíto para a ação. Por exemplo:

<ruby>
map.resources :photos, :new => { :new => :any }
</ruby>

Isto permitirá que a ação new seja invocada por qualquer requisição para +photos/new+, não importa o verbo HTTp que você use.

h5. Uma nota de cuidado

Se você está adicionando muitas rotas extras para uma rota RESTful, é hora de parar e se perguntar se você está disfarçando a presença de outro recurso que seria melhor utilizar o seu próprio. Quando o +:member+ e +:collection+ se tornam um lixo, então as rotas RESTful perdem a vantagem da facilidade de legibilidade, que é um de seus pontos fortes.

h3. Rotas Regulares

Além do roteamento RESTful, Rails suporta roteamento regular - a forma para mapear URLs para controladores e ações. Com o roteamento regular, você não recebe a massas de rotas geradas automaticamentes pelo roteamento RESTful. Em vez disso, você deve configurar cada rota dentro do seu aplicativo separadamente.

Enquanto o roteamento RESTful tornou-se o padrão Rails, ainda há muitos lugares onde o simples roteamento regular funciona perfeitamente. Você pode mesclar os dois estilos junto em uma única aplicação. Geralmente, você deve preferir o roteamento RESTful _quando possível_, por quê fará partes da sua aplicação serem escritas mais fáceis. Mas não é necessariamente tentar forçar cada última peça da sua aplicação dentro de um framework RESTful se isto não é um bom ajuste.

h4. Paramêtros Obrigatórios

Quando você configurar uma rota regular,você fornece uma série de símbolos que o Rails mapeia partes de uma requisição HTTP de entrada. Dois desses símbolos são especiais: +:controller+ mapeia para o nome do controlador na sua aplicação, e +:action+ mapeia para o nome da ação do respectivo controlador. Por exemplo, considere uma rota Rails padrão:

<ruby>
map.connect ':controller/:action/:id'
</ruby>

Se a requisição de entrada para +/photos/show/1+ é processada para esta rota (por quê não correspondeu com qualquer rota previamente no arquivo), então o resultado é que será invocado a ação +show+ do controlador +Photos+, e contruída com o parâmetro final (1) disponível como +params[:id]+.

h4. Componentes Coringas

Você pode configurar vários símbolos coringas junto com as rotas regulares como você quiser. Qualquer outra coisa diferente de +:controller+ ou +:action+ estará disponível para combinar a ação com a parte dos parâmetros da hash. Então, se você configurar rota como esta:

<ruby>
map.connect ':controller/:action/:id/:user_id'
</ruby>

A chegada de uma URL de +/photos/show/1/2+ será despachada para a ação +show+ do controlador +Photos+. +params[:id]+ será definido para 1, e +params[:user_id]+ será definido para 2.

h4. Texto Estático

Você pode especificar um texto estático quando cria a rota. Neste caso, o texto estático é usado somente para combinar com as solicitações de entrada:

<ruby>
map.connect ':controller/:action/:id/with_user/:user_id'
</ruby>

Esta rota deverá responder para URLs como +/photos/show/1/with_user/2+.

h4. Querystring Parâmetros

O roteamento Rails automaticamente pega parâmetros de querystring e os torna disponíveis na hash +params+. Por exemplo, com esta rota:

<ruby>
map.connect ':controller/:action/:id'
</ruby>

Solicitações de URL para +/photos/show/1?user_id=2+ será despachada para a ação +show+ do controlador +Photos+. +params[:id]+ será definido como 1, e +params[:user_id]+ será definido como 2.

h4. Definindo Padrões

Você não precisa explicitamente usar o símbolos +:controller+ e +:action+ juntamente com a rota. Você pode fornecer padrões para esses dois parâmetros em uma hash:

<ruby>
map.connect 'photo/:id', :controller => 'photos', :action => 'show'
</ruby>

Com esta rota, chamadas URL para +/photos/12+ será despachado para a ação +show+ juntamente para o controlador +Photos+.

Você pode definir outros padrões na rota fornecendo uma hash para a opção +:defaults+. Isto mesmo se aplica para os parâmetros que não estão explicitamente definidos em outros locais na rota. Por exemplo:

<ruby>
map.connect 'photo/:id', :controller => 'photos', :action => 'show', :defaults => { :format => 'jpg' }
</ruby>

Com esta rota, solicitações URL para +photos/12+ serão despachado para a ação +show+ juntamente para o controlador +Photos+, e o +params[:format]+ será definido para +jpg+.

h4. Rotas Nomeadas

Rotas regulares não precisa usar o método +connect+. Você pode usar qualquer outro nome para criar uma _rota nomeada_. Por exemplo,

<ruby>
map.logout '/logout', :controller => 'sessions', :action => 'destroy'
</ruby>

Isto terá duas coisas. Primeiro, requisições para +/logout+ serão enviadas para o método +destroy+ do controlador +Sessions+. Segundo, Rails manterá os helpers +logout_path+ e +logout_url+ para usar nos seus códigos.

h4. Requisitos de Rota

Você pode usar a opção +:requirements+ para obrigar um formato para qualquer parâmetro na rota:

<ruby>
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
 :requirements => { :id => /[A-Z]\d{5}/ }
</ruby>

Isso irá responder para URLs como +/photo/A12345+. Você pode expressar sucintamente a mesma rota desta forma:

<ruby>
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
  :id => /[A-Z]\d{5}/ 
</ruby>

h4. Condições na Rota

Condições na rota (introduzido com a opção +:conditions+) são projetados para implementar restrições nas rotas. Atualmente, somente a restrição suportada é +:method+.

<ruby>
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
 :conditions => { :method => :get }
</ruby>

Como nas condições em rotas RESTful, você pode especificar +:get+, +:post+, +:put+, +:delete+, ou +:any+ para os métodos aceitáveis.

h4. Englobamento de Rota

O englobamento de rota é a forma de especifícar um parâmetro em particulpar (que deve ser o último parâmetro na rota) deverá combinar com todas as partes restantes da rota. Por exemple

<ruby>
map.connect 'photo/*other', :controller => 'photos', :action => 'unknown',
</ruby>

Esta rota deverá combinar com +photo/12+ ou +/photo/long/path/to/12+ igualmente, criando um array de caminhos como o valor +params[:other]+

h4. Opções de Rotas

Você pode usar +:with_options+

Você pode usar +:with_options+ para simplificar a definindo grupos de rotas similares:

<ruby>
map.with_options :controller => 'photo' do |photo|
  photo.list '', :action => 'index'
  photo.delete ':id/delete', :action => 'delete'
  photo.edit ':id/edit', :action => 'edit'
end
</ruby>

A importância de +map.with_options+ está declinando com a introdução de rotas RESTful.

h3. Formatos e respond_to

Há mais de uma forma de roteamento que pode fazer coisas diferentes dependendo das diferenças nas solicitações HTTP: pela emissão de respostas que corresponde como a requisição específica será aceita. No roteamento Rails, você pode controlar isto em especial com o parâmetro +:format+ na rota.

Por exemplo, considere o segundo padrão de rotas nos padrões do arquivo +routes.rb+:

<ruby>
map.connect ':controller/:action/:id.:format'
</ruby>

Esta rota combina com requisições como +/photo/edit/1.xml+ ou +/photo/show/2.rss+. Juntamente com o código apropriado, você pode diferenciar a resposta dependendo de como ela foi requisitada:

<ruby>
respond_to do |format|
  format.html # return the default template for HTML
  format.xml { render :xml => @photo.to_xml }
end
</ruby>

h4. Especificando o Formato com um cabeçalho HTTP

Se não houver o parâmetro +:format+ na rota, o Rails automaticamente olhará para o cabeçalho HTTP Accept para determinar o formato desejado.

h4. Reconhecendo tipos MIME

Por padrão, o Rails reconhece +html+, +text+, +json+, +csv+, +xml+, +rss+, +atom+, e +yaml+ como tipos de respostas aceitáveis. Se você necessita de tipos por trás disso, você pode registrar isto no seu environment:

<ruby>
Mime::Type.register "image/jpg", :jpg
</ruby>

h3. As Rotas Padrões

Quando você cria uma nova aplicação Rails, +routes.rb+ é inicializado com essas duas rotas padrões:

<ruby>
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
</ruby>

Essas rotas fornecem razoáveis padrões para muitas URLs, se você não está usando roteamento RESTful.

NOTE: O padrão de rotas fará a cada ação para cada controlador na sua aplicação acessível por requisições GET. Se você conceber sua aplicação para fazer o uso consistente de RESTful e rotas nomeadas, você deve comentar as rotas padrões para previnir o acesso de seus controladores atráves de verbos errados. Se você tiver as rotas padrões habilidades durante o desenvolvimento, embora, você precisa ter certeza de que não tenha involutariamente dependente deles em algum lugar da sua aplicação - de outra forma você pode encontrar falhas misteriosas quando você desativá-las.

h3. A Rota Vazia

Não confuda as rotas padrões com a rota vazia. A rota vazia tem uma finalidade específica: para requisitar os pedidos dentro da raiz do web site. Por exemplo, se seu site é example.com, então as requisições para +http://example.com+ ou +http://example.com/+ serão tratadas pela rota vazia.

h4. Usando map.root

A forma preferida de configurar uma rota vazia é com o comando +map.root+:

<ruby>
map.root :controller => "pages", :action => "main"
</ruby>

O uso do método +root+ fornece Rails que esta rota deve ser aplicada quando requisitado a raiz do site.

Para uma melhor legibilidade, você pode especificar uma rota já criada na chamda para +map.root+:

<ruby>
map.index :controller => "pages", :action => "main"
map.root :index
</ruby>

Por causa do processamento de cima para baixo do arquivo, a rota nomeada deve ser especifícada _antes_ da chamada para +map.root+.

h4. Conectando uma String Vazia

Você pode especificar uma rota vazia explicitamente conectando uma string vazia:

<ruby>
map.connect '', :controller => "pages", :action => "main"
</ruby>

TIP: Se a rota vazia não parece que está funcionando na sua aplicação, tenha certeza que você tenha deletado o arquivo +public/index.html+ da sua árvore Rails.

h3. Inspencionando e Testando Rotas

Roteando na sua aplicação não deve ser uma "caixa preta" que você nunca abrirá. O Rails oferece ferramentas prontas tanto para inspecionar e testas as rotas.

h4. Vendo Rotas Existentes com Rake

Se você precisa de uma lista de todas as rotas disponíveis na sua aplicação, roda o comando +rake routes+. Irá descarregar todas as rotas para o console, na mesma ordem que aparecem em +routes.rb+. Para cada rota, você verá:

* O nome da rota (se houver)
* O verbo HTTP usado (se a rota não responder para todos os verbos)
* O padrão de URL
* Os parâmetros de roteamento que serão gerados pela URL

Por exemplo, aqui é uma pequena seção da saída do +rake routes+ para uma rota RESTful:

<pre>
          users GET  /users          {:controller=>"users", :action=>"index"}
formatted_users GET  /users.:format  {:controller=>"users", :action=>"index"}
                POST /users          {:controller=>"users", :action=>"create"}
                POST /users.:format  {:controller=>"users", :action=>"create"}
</pre>

TIP: Você verá que a saída de +rake routes+ é muito mais legível se você aumentar a janela do terminal até que as linhas de saída não se enrolem

h4. Testando Rotas

Rotas devem ser incluídas na sua estratégia de teste (assim como o resto da sua aplicação). Rails oferece três "built-in assertions":http://api.rubyonrails.com/classes/ActionController/Assertions/RoutingAssertions.html projetado para testar rotas mais simples:

* +assert_generates+
* +assert_recognizes+
* +assert_routing+

h5. A Assertion The +assert_generates+

Use +assert_generates+ para afirmar que um conjunto particular de opções gera um caminho particular. Você pode usar junto com as rotas padrões ou com rotas customizadas.

<ruby>
assert_generates "/photos/1", { :controller => "photos", :action => "show", :id => "1" }
assert_generates "/about", :controller => "pages", :action => "about"
</ruby>

h5. A Assertion +assert_recognizes+

A afirmação +assert_recognizes+ é o inverso da +assert_generates+. Ela afirma ao Rails reconhecer os caminhos recebidos e as rotas para um local em particulpar na sua aplicação.

<ruby>
assert_recognizes { :controller => "photos", :action => "show", :id => "1" }, "/photos/1"
</ruby>

Você pode fornecer o argumento +:method+ para especificar um verbo HTTP:

<ruby>
assert_recognizes { :controller => "photos", :action => "create" }, { :path => "photos", :method => :post }
</ruby>

Você também pode usar helpers RESTful para testar o reconhecimento da rota RESTful:

<ruby>
assert_recognizes new_photo_url, { :path => "photos", :method => :post }
</ruby>

h5. A Assertion +assert_routing+ 

A afirmação +assert_routing+ verifica a rota de duas formas: testa se o caminho gera as opções, e que as opções geram o caminho. Deste modo, combina as funções de +assert_generates+ e +assert_recognizes+.

<ruby>
assert_routing { :path => "photos", :method => :post }, { :controller => "photos", :action => "create" }
</ruby>

h3. Changelog

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/3

* October 4, 2008: Added additional detail on specifying verbs for resource member/collection routes , by "Mike Gunderloy":credits.html#mgunderloy
* September 23, 2008: Added section on namespaced controllers and routing, by "Mike Gunderloy":credits.html#mgunderloy
* September 10, 2008: initial version by "Mike Gunderloy":credits.html#mgunderloy
* March, 14, 2009: translated by "Cairo Noleto":credits.html#caironoleto
